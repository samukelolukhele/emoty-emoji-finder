{"ast":null,"code":"/*!\n * Copyright (c) 2015, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _require = require(\"universalify\"),\n    fromCallback = _require.fromCallback;\n\nvar Store = require(\"./store\").Store;\n\nvar permuteDomain = require(\"./permuteDomain\").permuteDomain;\n\nvar pathMatch = require(\"./pathMatch\").pathMatch;\n\nvar util = require(\"util\");\n\nvar MemoryCookieStore = /*#__PURE__*/function (_Store) {\n  _inherits(MemoryCookieStore, _Store);\n\n  var _super = _createSuper(MemoryCookieStore);\n\n  function MemoryCookieStore() {\n    var _this;\n\n    _classCallCheck(this, MemoryCookieStore);\n\n    _this = _super.call(this);\n    _this.synchronous = true;\n    _this.idx = {};\n\n    if (util.inspect.custom) {\n      _this[util.inspect.custom] = _this.inspect;\n    }\n\n    return _this;\n  }\n\n  _createClass(MemoryCookieStore, [{\n    key: \"inspect\",\n    value: function inspect() {\n      return \"{ idx: \".concat(util.inspect(this.idx, false, 2), \" }\");\n    }\n  }, {\n    key: \"findCookie\",\n    value: function findCookie(domain, path, key, cb) {\n      if (!this.idx[domain]) {\n        return cb(null, undefined);\n      }\n\n      if (!this.idx[domain][path]) {\n        return cb(null, undefined);\n      }\n\n      return cb(null, this.idx[domain][path][key] || null);\n    }\n  }, {\n    key: \"findCookies\",\n    value: function findCookies(domain, path, allowSpecialUseDomain, cb) {\n      var results = [];\n\n      if (typeof allowSpecialUseDomain === \"function\") {\n        cb = allowSpecialUseDomain;\n        allowSpecialUseDomain = false;\n      }\n\n      if (!domain) {\n        return cb(null, []);\n      }\n\n      var pathMatcher;\n\n      if (!path) {\n        // null means \"all paths\"\n        pathMatcher = function matchAll(domainIndex) {\n          for (var curPath in domainIndex) {\n            var pathIndex = domainIndex[curPath];\n\n            for (var key in pathIndex) {\n              results.push(pathIndex[key]);\n            }\n          }\n        };\n      } else {\n        pathMatcher = function matchRFC(domainIndex) {\n          //NOTE: we should use path-match algorithm from S5.1.4 here\n          //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)\n          Object.keys(domainIndex).forEach(function (cookiePath) {\n            if (pathMatch(path, cookiePath)) {\n              var pathIndex = domainIndex[cookiePath];\n\n              for (var key in pathIndex) {\n                results.push(pathIndex[key]);\n              }\n            }\n          });\n        };\n      }\n\n      var domains = permuteDomain(domain, allowSpecialUseDomain) || [domain];\n      var idx = this.idx;\n      domains.forEach(function (curDomain) {\n        var domainIndex = idx[curDomain];\n\n        if (!domainIndex) {\n          return;\n        }\n\n        pathMatcher(domainIndex);\n      });\n      cb(null, results);\n    }\n  }, {\n    key: \"putCookie\",\n    value: function putCookie(cookie, cb) {\n      if (!this.idx[cookie.domain]) {\n        this.idx[cookie.domain] = {};\n      }\n\n      if (!this.idx[cookie.domain][cookie.path]) {\n        this.idx[cookie.domain][cookie.path] = {};\n      }\n\n      this.idx[cookie.domain][cookie.path][cookie.key] = cookie;\n      cb(null);\n    }\n  }, {\n    key: \"updateCookie\",\n    value: function updateCookie(oldCookie, newCookie, cb) {\n      // updateCookie() may avoid updating cookies that are identical.  For example,\n      // lastAccessed may not be important to some stores and an equality\n      // comparison could exclude that field.\n      this.putCookie(newCookie, cb);\n    }\n  }, {\n    key: \"removeCookie\",\n    value: function removeCookie(domain, path, key, cb) {\n      if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {\n        delete this.idx[domain][path][key];\n      }\n\n      cb(null);\n    }\n  }, {\n    key: \"removeCookies\",\n    value: function removeCookies(domain, path, cb) {\n      if (this.idx[domain]) {\n        if (path) {\n          delete this.idx[domain][path];\n        } else {\n          delete this.idx[domain];\n        }\n      }\n\n      return cb(null);\n    }\n  }, {\n    key: \"removeAllCookies\",\n    value: function removeAllCookies(cb) {\n      this.idx = {};\n      return cb(null);\n    }\n  }, {\n    key: \"getAllCookies\",\n    value: function getAllCookies(cb) {\n      var cookies = [];\n      var idx = this.idx;\n      var domains = Object.keys(idx);\n      domains.forEach(function (domain) {\n        var paths = Object.keys(idx[domain]);\n        paths.forEach(function (path) {\n          var keys = Object.keys(idx[domain][path]);\n          keys.forEach(function (key) {\n            if (key !== null) {\n              cookies.push(idx[domain][path][key]);\n            }\n          });\n        });\n      }); // Sort by creationIndex so deserializing retains the creation order.\n      // When implementing your own store, this SHOULD retain the order too\n\n      cookies.sort(function (a, b) {\n        return (a.creationIndex || 0) - (b.creationIndex || 0);\n      });\n      cb(null, cookies);\n    }\n  }]);\n\n  return MemoryCookieStore;\n}(Store);\n\n[\"findCookie\", \"findCookies\", \"putCookie\", \"updateCookie\", \"removeCookie\", \"removeCookies\", \"removeAllCookies\", \"getAllCookies\"].forEach(function (name) {\n  MemoryCookieStore[name] = fromCallback(MemoryCookieStore.prototype[name]);\n});\nexports.MemoryCookieStore = MemoryCookieStore;","map":null,"metadata":{},"sourceType":"script"}