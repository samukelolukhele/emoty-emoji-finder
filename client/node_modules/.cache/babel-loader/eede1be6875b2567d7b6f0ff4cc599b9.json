{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/regenerator\");\n\nvar _toConsumableArray = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(shadowIncludingInclusiveDescendantsIterator),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(shadowIncludingDescendantsIterator);\n\nvar NODE_TYPE = require(\"../node-type\");\n\nvar _require = require(\"./node\"),\n    nodeRoot = _require.nodeRoot;\n\nvar _require2 = require(\"./namespaces\"),\n    HTML_NS = _require2.HTML_NS;\n\nvar _require3 = require(\"./internal-constants\"),\n    domSymbolTree = _require3.domSymbolTree;\n\nvar _require4 = require(\"./mutation-observers\"),\n    signalSlotList = _require4.signalSlotList,\n    queueMutationObserverMicrotask = _require4.queueMutationObserverMicrotask; // Valid host element for ShadowRoot.\n// Defined in: https://dom.spec.whatwg.org/#dom-element-attachshadow\n\n\nvar VALID_HOST_ELEMENT_NAME = new Set([\"article\", \"aside\", \"blockquote\", \"body\", \"div\", \"footer\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"header\", \"main\", \"nav\", \"p\", \"section\", \"span\"]);\n\nfunction isValidHostElementName(name) {\n  return VALID_HOST_ELEMENT_NAME.has(name);\n} // Use an approximation by checking the presence of nodeType instead of instead of using the isImpl from\n// \"../generated/Node\" to avoid introduction of circular dependencies.\n\n\nfunction isNode(nodeImpl) {\n  return Boolean(nodeImpl && \"nodeType\" in nodeImpl);\n} // Use an approximation by checking the value of nodeType and presence of nodeType host instead of instead\n// of using the isImpl from \"../generated/ShadowRoot\" to avoid introduction of circular dependencies.\n\n\nfunction isShadowRoot(nodeImpl) {\n  return Boolean(nodeImpl && nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE && \"host\" in nodeImpl);\n} // https://dom.spec.whatwg.org/#concept-slotable\n\n\nfunction isSlotable(nodeImpl) {\n  return nodeImpl && (nodeImpl.nodeType === NODE_TYPE.ELEMENT_NODE || nodeImpl.nodeType === NODE_TYPE.TEXT_NODE);\n}\n\nfunction isSlot(nodeImpl) {\n  return nodeImpl && nodeImpl.localName === \"slot\" && nodeImpl._namespaceURI === HTML_NS;\n} // https://dom.spec.whatwg.org/#concept-shadow-including-inclusive-ancestor\n\n\nfunction isShadowInclusiveAncestor(ancestor, node) {\n  while (isNode(node)) {\n    if (node === ancestor) {\n      return true;\n    }\n\n    if (isShadowRoot(node)) {\n      node = node.host;\n    } else {\n      node = domSymbolTree.parent(node);\n    }\n  }\n\n  return false;\n} // https://dom.spec.whatwg.org/#retarget\n\n\nfunction retarget(a, b) {\n  while (true) {\n    if (!isNode(a)) {\n      return a;\n    }\n\n    var aRoot = nodeRoot(a);\n\n    if (!isShadowRoot(aRoot) || isNode(b) && isShadowInclusiveAncestor(aRoot, b)) {\n      return a;\n    }\n\n    a = nodeRoot(a).host;\n  }\n} // https://dom.spec.whatwg.org/#get-the-parent\n\n\nfunction getEventTargetParent(eventTarget, event) {\n  // _getTheParent will be missing for Window, since it doesn't have an impl class and we don't want to pollute the\n  // user-visible global scope with a _getTheParent value. TODO: remove this entire function and use _getTheParent\n  // directly, once Window gets split into impl/wrapper.\n  return eventTarget._getTheParent ? eventTarget._getTheParent(event) : null;\n} // https://dom.spec.whatwg.org/#concept-shadow-including-root\n\n\nfunction shadowIncludingRoot(node) {\n  var root = nodeRoot(node);\n  return isShadowRoot(root) ? shadowIncludingRoot(root.host) : root;\n} // https://dom.spec.whatwg.org/#assign-a-slot\n\n\nfunction assignSlot(slotable) {\n  var slot = findSlot(slotable);\n\n  if (slot) {\n    assignSlotable(slot);\n  }\n} // https://dom.spec.whatwg.org/#assign-slotables\n\n\nfunction assignSlotable(slot) {\n  var slotables = findSlotable(slot);\n  var shouldFireSlotChange = false;\n\n  if (slotables.length !== slot._assignedNodes.length) {\n    shouldFireSlotChange = true;\n  } else {\n    for (var i = 0; i < slotables.length; i++) {\n      if (slotables[i] !== slot._assignedNodes[i]) {\n        shouldFireSlotChange = true;\n        break;\n      }\n    }\n  }\n\n  if (shouldFireSlotChange) {\n    signalSlotChange(slot);\n  }\n\n  slot._assignedNodes = slotables;\n\n  var _iterator = _createForOfIteratorHelper(slotables),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var slotable = _step.value;\n      slotable._assignedSlot = slot;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n} // https://dom.spec.whatwg.org/#assign-slotables-for-a-tree\n\n\nfunction assignSlotableForTree(root) {\n  var _iterator2 = _createForOfIteratorHelper(domSymbolTree.treeIterator(root)),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var slot = _step2.value;\n\n      if (isSlot(slot)) {\n        assignSlotable(slot);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n} // https://dom.spec.whatwg.org/#find-slotables\n\n\nfunction findSlotable(slot) {\n  var result = [];\n  var root = nodeRoot(slot);\n\n  if (!isShadowRoot(root)) {\n    return result;\n  }\n\n  var _iterator3 = _createForOfIteratorHelper(domSymbolTree.treeIterator(root.host)),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var slotable = _step3.value;\n      var foundSlot = findSlot(slotable);\n\n      if (foundSlot === slot) {\n        result.push(slotable);\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return result;\n} // https://dom.spec.whatwg.org/#find-flattened-slotables\n\n\nfunction findFlattenedSlotables(slot) {\n  var result = [];\n  var root = nodeRoot(slot);\n\n  if (!isShadowRoot(root)) {\n    return result;\n  }\n\n  var slotables = findSlotable(slot);\n\n  if (slotables.length === 0) {\n    var _iterator4 = _createForOfIteratorHelper(domSymbolTree.childrenIterator(slot)),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var child = _step4.value;\n\n        if (isSlotable(child)) {\n          slotables.push(child);\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n\n  var _iterator5 = _createForOfIteratorHelper(slotables),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var node = _step5.value;\n\n      if (isSlot(node) && isShadowRoot(nodeRoot(node))) {\n        var temporaryResult = findFlattenedSlotables(node);\n        result.push.apply(result, _toConsumableArray(temporaryResult));\n      } else {\n        result.push(node);\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return result;\n} // https://dom.spec.whatwg.org/#find-a-slot\n\n\nfunction findSlot(slotable, openFlag) {\n  var parent = slotable.parentNode;\n\n  if (!parent) {\n    return null;\n  }\n\n  var shadow = parent._shadowRoot;\n\n  if (!shadow || openFlag && shadow.mode !== \"open\") {\n    return null;\n  }\n\n  var _iterator6 = _createForOfIteratorHelper(domSymbolTree.treeIterator(shadow)),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var child = _step6.value;\n\n      if (isSlot(child) && child.name === slotable._slotableName) {\n        return child;\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  return null;\n} // https://dom.spec.whatwg.org/#signal-a-slot-change\n\n\nfunction signalSlotChange(slot) {\n  if (!signalSlotList.some(function (entry) {\n    return entry === slot;\n  })) {\n    signalSlotList.push(slot);\n  }\n\n  queueMutationObserverMicrotask();\n} // https://dom.spec.whatwg.org/#concept-shadow-including-descendant\n\n\nfunction shadowIncludingInclusiveDescendantsIterator(node) {\n  var _iterator7, _step7, child;\n\n  return _regeneratorRuntime.wrap(function shadowIncludingInclusiveDescendantsIterator$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return node;\n\n        case 2:\n          if (!node._shadowRoot) {\n            _context.next = 4;\n            break;\n          }\n\n          return _context.delegateYield(shadowIncludingInclusiveDescendantsIterator(node._shadowRoot), \"t0\", 4);\n\n        case 4:\n          _iterator7 = _createForOfIteratorHelper(domSymbolTree.childrenIterator(node));\n          _context.prev = 5;\n\n          _iterator7.s();\n\n        case 7:\n          if ((_step7 = _iterator7.n()).done) {\n            _context.next = 12;\n            break;\n          }\n\n          child = _step7.value;\n          return _context.delegateYield(shadowIncludingInclusiveDescendantsIterator(child), \"t1\", 10);\n\n        case 10:\n          _context.next = 7;\n          break;\n\n        case 12:\n          _context.next = 17;\n          break;\n\n        case 14:\n          _context.prev = 14;\n          _context.t2 = _context[\"catch\"](5);\n\n          _iterator7.e(_context.t2);\n\n        case 17:\n          _context.prev = 17;\n\n          _iterator7.f();\n\n          return _context.finish(17);\n\n        case 20:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[5, 14, 17, 20]]);\n} // https://dom.spec.whatwg.org/#concept-shadow-including-descendant\n\n\nfunction shadowIncludingDescendantsIterator(node) {\n  var _iterator8, _step8, child;\n\n  return _regeneratorRuntime.wrap(function shadowIncludingDescendantsIterator$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!node._shadowRoot) {\n            _context2.next = 2;\n            break;\n          }\n\n          return _context2.delegateYield(shadowIncludingInclusiveDescendantsIterator(node._shadowRoot), \"t0\", 2);\n\n        case 2:\n          _iterator8 = _createForOfIteratorHelper(domSymbolTree.childrenIterator(node));\n          _context2.prev = 3;\n\n          _iterator8.s();\n\n        case 5:\n          if ((_step8 = _iterator8.n()).done) {\n            _context2.next = 10;\n            break;\n          }\n\n          child = _step8.value;\n          return _context2.delegateYield(shadowIncludingInclusiveDescendantsIterator(child), \"t1\", 8);\n\n        case 8:\n          _context2.next = 5;\n          break;\n\n        case 10:\n          _context2.next = 15;\n          break;\n\n        case 12:\n          _context2.prev = 12;\n          _context2.t2 = _context2[\"catch\"](3);\n\n          _iterator8.e(_context2.t2);\n\n        case 15:\n          _context2.prev = 15;\n\n          _iterator8.f();\n\n          return _context2.finish(15);\n\n        case 18:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[3, 12, 15, 18]]);\n}\n\nmodule.exports = {\n  isValidHostElementName: isValidHostElementName,\n  isNode: isNode,\n  isSlotable: isSlotable,\n  isSlot: isSlot,\n  isShadowRoot: isShadowRoot,\n  isShadowInclusiveAncestor: isShadowInclusiveAncestor,\n  retarget: retarget,\n  getEventTargetParent: getEventTargetParent,\n  shadowIncludingRoot: shadowIncludingRoot,\n  assignSlot: assignSlot,\n  assignSlotable: assignSlotable,\n  assignSlotableForTree: assignSlotableForTree,\n  findSlot: findSlot,\n  findFlattenedSlotables: findFlattenedSlotables,\n  signalSlotChange: signalSlotChange,\n  shadowIncludingInclusiveDescendantsIterator: shadowIncludingInclusiveDescendantsIterator,\n  shadowIncludingDescendantsIterator: shadowIncludingDescendantsIterator\n};","map":null,"metadata":{},"sourceType":"script"}