{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar vm = require(\"vm\");\n\nvar whatwgEncoding = require(\"whatwg-encoding\");\n\nvar MIMEType = require(\"whatwg-mimetype\");\n\nvar _require = require(\"whatwg-url\"),\n    serializeURL = _require.serializeURL;\n\nvar HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nvar reportException = require(\"../helpers/runtime-script-errors\");\n\nvar _require2 = require(\"../helpers/internal-constants\"),\n    domSymbolTree = _require2.domSymbolTree,\n    cloningSteps = _require2.cloningSteps;\n\nvar _require3 = require(\"../helpers/strings\"),\n    asciiLowercase = _require3.asciiLowercase;\n\nvar _require4 = require(\"../helpers/text\"),\n    childTextContent = _require4.childTextContent;\n\nvar _require5 = require(\"../helpers/events\"),\n    fireAnEvent = _require5.fireAnEvent;\n\nvar _require6 = require(\"../helpers/document-base-url\"),\n    parseURLToResultingURLRecord = _require6.parseURLToResultingURLRecord;\n\nvar nodeTypes = require(\"../node-type\");\n\nvar jsMIMETypes = new Set([\"application/ecmascript\", \"application/javascript\", \"application/x-ecmascript\", \"application/x-javascript\", \"text/ecmascript\", \"text/javascript\", \"text/javascript1.0\", \"text/javascript1.1\", \"text/javascript1.2\", \"text/javascript1.3\", \"text/javascript1.4\", \"text/javascript1.5\", \"text/jscript\", \"text/livescript\", \"text/x-ecmascript\", \"text/x-javascript\"]);\n\nvar HTMLScriptElementImpl = /*#__PURE__*/function (_HTMLElementImpl) {\n  _inherits(HTMLScriptElementImpl, _HTMLElementImpl);\n\n  var _super = _createSuper(HTMLScriptElementImpl);\n\n  function HTMLScriptElementImpl(globalObject, args, privateData) {\n    var _this;\n\n    _classCallCheck(this, HTMLScriptElementImpl);\n\n    _this = _super.call(this, globalObject, args, privateData);\n    _this._alreadyStarted = false;\n    _this._parserInserted = false; // set by the parser\n\n    return _this;\n  }\n\n  _createClass(HTMLScriptElementImpl, [{\n    key: \"_attach\",\n    value: function _attach() {\n      _get(_getPrototypeOf(HTMLScriptElementImpl.prototype), \"_attach\", this).call(this); // In our current terribly-hacky document.write() implementation, we parse in a div them move elements into the main\n      // document. Thus _eval() will bail early when it gets in _poppedOffStackOfOpenElements(), since we're not attached\n      // then. Instead, we'll let it eval here.\n\n\n      if (!this._parserInserted || this._isMovingDueToDocumentWrite) {\n        this._eval();\n      }\n    }\n  }, {\n    key: \"_canRunScript\",\n    value: function _canRunScript() {\n      var document = this._ownerDocument; // Equivalent to the spec's \"scripting is disabled\" check.\n\n      if (!document._defaultView || document._defaultView._runScripts !== \"dangerously\" || document._scriptingDisabled) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_fetchExternalScript\",\n    value: function _fetchExternalScript() {\n      var _this2 = this;\n\n      var document = this._ownerDocument;\n      var resourceLoader = document._resourceLoader;\n\n      var defaultEncoding = whatwgEncoding.labelToName(this.getAttributeNS(null, \"charset\")) || document._encoding;\n\n      var request;\n\n      if (!this._canRunScript()) {\n        return;\n      }\n\n      var src = this.getAttributeNS(null, \"src\");\n      var url = parseURLToResultingURLRecord(src, this._ownerDocument);\n\n      if (url === null) {\n        return;\n      }\n\n      var urlString = serializeURL(url);\n\n      var onLoadExternalScript = function onLoadExternalScript(data) {\n        var _request = request,\n            response = _request.response;\n        var contentType;\n\n        if (response && response.statusCode !== undefined && response.statusCode >= 400) {\n          throw new Error(\"Status code: \" + response.statusCode);\n        }\n\n        if (response) {\n          contentType = MIMEType.parse(response.headers[\"content-type\"]) || new MIMEType(\"text/plain\");\n        }\n\n        var encoding = whatwgEncoding.getBOMEncoding(data) || contentType && whatwgEncoding.labelToName(contentType.parameters.get(\"charset\")) || defaultEncoding;\n        var script = whatwgEncoding.decode(data, encoding);\n\n        _this2._innerEval(script, urlString);\n      };\n\n      request = resourceLoader.fetch(urlString, {\n        element: this,\n        onLoad: onLoadExternalScript\n      });\n    }\n  }, {\n    key: \"_fetchInternalScript\",\n    value: function _fetchInternalScript() {\n      var _this3 = this;\n\n      var document = this._ownerDocument;\n\n      if (!this._canRunScript()) {\n        return;\n      }\n\n      document._queue.push(null, function () {\n        _this3._innerEval(_this3.text, document.URL);\n\n        fireAnEvent(\"load\", _this3);\n      }, null, false, this);\n    }\n  }, {\n    key: \"_attrModified\",\n    value: function _attrModified(name, value, oldValue) {\n      _get(_getPrototypeOf(HTMLScriptElementImpl.prototype), \"_attrModified\", this).call(this, name, value, oldValue);\n\n      if (this._attached && !this._startedEval && name === \"src\" && oldValue === null && value !== null) {\n        this._fetchExternalScript();\n      }\n    }\n  }, {\n    key: \"_poppedOffStackOfOpenElements\",\n    value: function _poppedOffStackOfOpenElements() {\n      // This seems to roughly correspond to\n      // https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-incdata:prepare-a-script, although we certainly\n      // don't implement the full semantics.\n      this._eval();\n    } // Vaguely similar to https://html.spec.whatwg.org/multipage/scripting.html#prepare-a-script, but we have a long way\n    // to go before it's aligned.\n\n  }, {\n    key: \"_eval\",\n    value: function _eval() {\n      if (this._alreadyStarted) {\n        return;\n      } // TODO: this text check doesn't seem completely the same as the spec, which e.g. will try to execute scripts with\n      // child element nodes. Spec bug? https://github.com/whatwg/html/issues/3419\n\n\n      if (!this.hasAttributeNS(null, \"src\") && this.text.length === 0) {\n        return;\n      }\n\n      if (!this._attached) {\n        return;\n      }\n\n      var scriptBlocksTypeString = this._getTypeString();\n\n      var type = getType(scriptBlocksTypeString);\n\n      if (type !== \"classic\") {\n        // TODO: implement modules, and then change the check to `type === null`.\n        return;\n      }\n\n      this._alreadyStarted = true; // TODO: implement nomodule here, **but only after we support modules**.\n      // At this point we completely depart from the spec.\n\n      if (this.hasAttributeNS(null, \"src\")) {\n        this._fetchExternalScript();\n      } else {\n        this._fetchInternalScript();\n      }\n    }\n  }, {\n    key: \"_innerEval\",\n    value: function _innerEval(text, filename) {\n      this._ownerDocument._writeAfterElement = this;\n      processJavaScript(this, text, filename);\n      delete this._ownerDocument._writeAfterElement;\n    }\n  }, {\n    key: \"_getTypeString\",\n    value: function _getTypeString() {\n      var typeAttr = this.getAttributeNS(null, \"type\");\n      var langAttr = this.getAttributeNS(null, \"language\");\n\n      if (typeAttr === \"\") {\n        return \"text/javascript\";\n      }\n\n      if (typeAttr === null && langAttr === \"\") {\n        return \"text/javascript\";\n      }\n\n      if (typeAttr === null && langAttr === null) {\n        return \"text/javascript\";\n      }\n\n      if (typeAttr !== null) {\n        return typeAttr.trim();\n      }\n\n      if (langAttr !== null) {\n        return \"text/\" + langAttr;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"text\",\n    get: function get() {\n      return childTextContent(this);\n    },\n    set: function set(text) {\n      this.textContent = text;\n    } // https://html.spec.whatwg.org/multipage/scripting.html#script-processing-model\n\n  }, {\n    key: cloningSteps,\n    value: function value(copy, node) {\n      copy._alreadyStarted = node._alreadyStarted;\n    }\n  }]);\n\n  return HTMLScriptElementImpl;\n}(HTMLElementImpl);\n\nfunction processJavaScript(element, code, filename) {\n  var document = element.ownerDocument;\n  var window = document && document._global;\n\n  if (window) {\n    document._currentScript = element;\n    var lineOffset = 0;\n\n    if (!element.hasAttributeNS(null, \"src\")) {\n      var _iterator = _createForOfIteratorHelper(domSymbolTree.childrenIterator(element)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n\n          if (child.nodeType === nodeTypes.TEXT_NODE) {\n            if (child.sourceCodeLocation) {\n              lineOffset = child.sourceCodeLocation.startLine - 1;\n            }\n\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    try {\n      vm.runInContext(code, window, {\n        filename: filename,\n        lineOffset: lineOffset,\n        displayErrors: false\n      });\n    } catch (e) {\n      reportException(window, e, filename);\n    } finally {\n      document._currentScript = null;\n    }\n  }\n}\n\nfunction getType(typeString) {\n  var lowercased = asciiLowercase(typeString); // Cannot use whatwg-mimetype parsing because that strips whitespace. The spec demands a strict string comparison.\n  // That is, the type=\"\" attribute is not really related to MIME types at all.\n\n  if (jsMIMETypes.has(lowercased)) {\n    return \"classic\";\n  }\n\n  if (lowercased === \"module\") {\n    return \"module\";\n  }\n\n  return null;\n}\n\nmodule.exports = {\n  implementation: HTMLScriptElementImpl\n};","map":null,"metadata":{},"sourceType":"script"}