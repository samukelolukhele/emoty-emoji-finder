{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _createForOfIteratorHelper = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/createClass\");\n\nvar parse5 = require(\"parse5\");\n\nvar _require = require(\"../../living/helpers/create-element\"),\n    _createElement = _require.createElement;\n\nvar _require2 = require(\"../../living/helpers/namespaces\"),\n    HTML_NS = _require2.HTML_NS;\n\nvar DocumentType = require(\"../../living/generated/DocumentType\");\n\nvar DocumentFragment = require(\"../../living/generated/DocumentFragment\");\n\nvar Text = require(\"../../living/generated/Text\");\n\nvar Comment = require(\"../../living/generated/Comment\");\n\nvar attributes = require(\"../../living/attributes\");\n\nvar nodeTypes = require(\"../../living/node-type\");\n\nvar serializationAdapter = require(\"../../living/domparsing/parse5-adapter-serialization\");\n\nvar _require3 = require(\"../../living/helpers/custom-elements\"),\n    customElementReactionsStack = _require3.customElementReactionsStack,\n    invokeCEReactions = _require3.invokeCEReactions,\n    lookupCEDefinition = _require3.lookupCEDefinition; // Horrible monkey-patch to implement https://github.com/inikulin/parse5/issues/237 and\n// https://github.com/inikulin/parse5/issues/285.\n\n\nvar OpenElementStack = require(\"parse5/lib/parser/open-element-stack\");\n\nvar openElementStackOriginalPush = OpenElementStack.prototype.push;\n\nOpenElementStack.prototype.push = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  openElementStackOriginalPush.apply(this, args);\n  this.treeAdapter._currentElement = this.current;\n  var after = this.items[this.stackTop];\n\n  if (after._pushedOnStackOfOpenElements) {\n    after._pushedOnStackOfOpenElements();\n  }\n};\n\nvar openElementStackOriginalPop = OpenElementStack.prototype.pop;\n\nOpenElementStack.prototype.pop = function () {\n  var before = this.items[this.stackTop];\n\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  openElementStackOriginalPop.apply(this, args);\n  this.treeAdapter._currentElement = this.current;\n\n  if (before._poppedOffStackOfOpenElements) {\n    before._poppedOffStackOfOpenElements();\n  }\n};\n\nvar JSDOMParse5Adapter = /*#__PURE__*/function () {\n  function JSDOMParse5Adapter(documentImpl) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, JSDOMParse5Adapter);\n\n    this._documentImpl = documentImpl;\n    this._globalObject = documentImpl._globalObject;\n    this._fragment = options.fragment || false; // Since the createElement hook doesn't provide the parent element, we keep track of this using _currentElement:\n    // https://github.com/inikulin/parse5/issues/285. See above horrible monkey-patch for how this is maintained.\n\n    this._currentElement = undefined;\n  }\n\n  _createClass(JSDOMParse5Adapter, [{\n    key: \"_ownerDocument\",\n    value: function _ownerDocument() {\n      var _currentElement = this._currentElement; // The _currentElement is undefined when parsing elements at the root of the document.\n\n      if (_currentElement) {\n        return _currentElement.localName === \"template\" && _currentElement.namespaceURI === HTML_NS ? _currentElement.content._ownerDocument : _currentElement._ownerDocument;\n      }\n\n      return this._documentImpl;\n    }\n  }, {\n    key: \"createDocument\",\n    value: function createDocument() {\n      // parse5's model assumes that parse(html) will call into here to create the new Document, then return it. However,\n      // jsdom's model assumes we can create a Window (and through that create an empty Document), do some other setup\n      // stuff, and then parse, stuffing nodes into that Document as we go. So to adapt between these two models, we just\n      // return the already-created Document when asked by parse5 to \"create\" a Document.\n      return this._documentImpl;\n    }\n  }, {\n    key: \"createDocumentFragment\",\n    value: function createDocumentFragment() {\n      var ownerDocument = this._ownerDocument();\n\n      return DocumentFragment.createImpl(this._globalObject, [], {\n        ownerDocument: ownerDocument\n      });\n    } // https://html.spec.whatwg.org/#create-an-element-for-the-token\n\n  }, {\n    key: \"createElement\",\n    value: function createElement(localName, namespace, attrs) {\n      var ownerDocument = this._ownerDocument();\n\n      var isAttribute = attrs.find(function (attr) {\n        return attr.name === \"is\";\n      });\n      var isValue = isAttribute ? isAttribute.value : null;\n      var definition = lookupCEDefinition(ownerDocument, namespace, localName);\n      var willExecuteScript = false;\n\n      if (definition !== null && !this._fragment) {\n        willExecuteScript = true;\n      }\n\n      if (willExecuteScript) {\n        ownerDocument._throwOnDynamicMarkupInsertionCounter++;\n        customElementReactionsStack.push([]);\n      }\n\n      var element = _createElement(ownerDocument, localName, namespace, null, isValue, willExecuteScript);\n\n      this.adoptAttributes(element, attrs);\n\n      if (willExecuteScript) {\n        var queue = customElementReactionsStack.pop();\n        invokeCEReactions(queue);\n        ownerDocument._throwOnDynamicMarkupInsertionCounter--;\n      }\n\n      if (\"_parserInserted\" in element) {\n        element._parserInserted = true;\n      }\n\n      return element;\n    }\n  }, {\n    key: \"createCommentNode\",\n    value: function createCommentNode(data) {\n      var ownerDocument = this._ownerDocument();\n\n      return Comment.createImpl(this._globalObject, [], {\n        data: data,\n        ownerDocument: ownerDocument\n      });\n    }\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(parentNode, newNode) {\n      parentNode._append(newNode);\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(parentNode, newNode, referenceNode) {\n      parentNode._insert(newNode, referenceNode);\n    }\n  }, {\n    key: \"setTemplateContent\",\n    value: function setTemplateContent(templateElement, contentFragment) {\n      // This code makes the glue between jsdom and parse5 HTMLTemplateElement parsing:\n      //\n      // * jsdom during the construction of the HTMLTemplateElement (for example when create via\n      //   `document.createElement(\"template\")`), creates a DocumentFragment and set it into _templateContents.\n      // * parse5 when parsing a <template> tag creates an HTMLTemplateElement (`createElement` adapter hook) and also\n      //   create a DocumentFragment (`createDocumentFragment` adapter hook).\n      //\n      // At this point we now have to replace the one created in jsdom with one created by parse5.\n      var _templateElement$_tem = templateElement._templateContents,\n          _ownerDocument = _templateElement$_tem._ownerDocument,\n          _host = _templateElement$_tem._host;\n      contentFragment._ownerDocument = _ownerDocument;\n      contentFragment._host = _host;\n      templateElement._templateContents = contentFragment;\n    }\n  }, {\n    key: \"setDocumentType\",\n    value: function setDocumentType(document, name, publicId, systemId) {\n      var ownerDocument = this._ownerDocument();\n\n      var documentType = DocumentType.createImpl(this._globalObject, [], {\n        name: name,\n        publicId: publicId,\n        systemId: systemId,\n        ownerDocument: ownerDocument\n      });\n\n      document._append(documentType);\n    }\n  }, {\n    key: \"setDocumentMode\",\n    value: function setDocumentMode(document, mode) {\n      // TODO: the rest of jsdom ignores this\n      document._mode = mode;\n    }\n  }, {\n    key: \"detachNode\",\n    value: function detachNode(node) {\n      node.remove();\n    }\n  }, {\n    key: \"insertText\",\n    value: function insertText(parentNode, text) {\n      var lastChild = parentNode.lastChild;\n\n      if (lastChild && lastChild.nodeType === nodeTypes.TEXT_NODE) {\n        lastChild.data += text;\n      } else {\n        var ownerDocument = this._ownerDocument();\n\n        var textNode = Text.createImpl(this._globalObject, [], {\n          data: text,\n          ownerDocument: ownerDocument\n        });\n\n        parentNode._append(textNode);\n      }\n    }\n  }, {\n    key: \"insertTextBefore\",\n    value: function insertTextBefore(parentNode, text, referenceNode) {\n      var previousSibling = referenceNode.previousSibling;\n\n      if (previousSibling && previousSibling.nodeType === nodeTypes.TEXT_NODE) {\n        previousSibling.data += text;\n      } else {\n        var ownerDocument = this._ownerDocument();\n\n        var textNode = Text.createImpl(this._globalObject, [], {\n          data: text,\n          ownerDocument: ownerDocument\n        });\n\n        parentNode._append(textNode, referenceNode);\n      }\n    }\n  }, {\n    key: \"adoptAttributes\",\n    value: function adoptAttributes(element, attrs) {\n      var _iterator = _createForOfIteratorHelper(attrs),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var attr = _step.value;\n          var prefix = attr.prefix === \"\" ? null : attr.prefix;\n          attributes.setAttributeValue(element, attr.name, attr.value, prefix, attr.namespace);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }]);\n\n  return JSDOMParse5Adapter;\n}(); // Assign shared adapters with serializer.\n\n\nObject.assign(JSDOMParse5Adapter.prototype, serializationAdapter);\n\nfunction parseFragment(markup, contextElement) {\n  var ownerDocument = contextElement.localName === \"template\" && contextElement.namespaceURI === HTML_NS ? contextElement.content._ownerDocument : contextElement._ownerDocument;\n\n  var config = _objectSpread(_objectSpread({}, ownerDocument._parseOptions), {}, {\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument, {\n      fragment: true\n    })\n  });\n\n  return parse5.parseFragment(contextElement, markup, config);\n}\n\nfunction parseIntoDocument(markup, ownerDocument) {\n  var config = _objectSpread(_objectSpread({}, ownerDocument._parseOptions), {}, {\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument)\n  });\n\n  return parse5.parse(markup, config);\n}\n\nmodule.exports = {\n  parseFragment: parseFragment,\n  parseIntoDocument: parseIntoDocument\n};","map":null,"metadata":{},"sourceType":"script"}