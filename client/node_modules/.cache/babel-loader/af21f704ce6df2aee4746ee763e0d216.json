{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _objectSpread = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _require = require(\"saxes\"),\n    SaxesParser = _require.SaxesParser;\n\nvar DOMException = require(\"domexception/webidl2js-wrapper\");\n\nvar _require2 = require(\"../../living/helpers/create-element\"),\n    createElement = _require2.createElement;\n\nvar DocumentFragment = require(\"../../living/generated/DocumentFragment\");\n\nvar DocumentType = require(\"../../living/generated/DocumentType\");\n\nvar CDATASection = require(\"../../living/generated/CDATASection\");\n\nvar Comment = require(\"../../living/generated/Comment\");\n\nvar ProcessingInstruction = require(\"../../living/generated/ProcessingInstruction\");\n\nvar Text = require(\"../../living/generated/Text\");\n\nvar attributes = require(\"../../living/attributes\");\n\nvar _require3 = require(\"../../living/helpers/namespaces\"),\n    HTML_NS = _require3.HTML_NS;\n\nvar HTML5_DOCTYPE = /<!doctype html>/i;\nvar PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\nvar SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\nvar CUSTOM_NAME_DOCTYPE = /<!doctype\\s+([^\\s>]+)/i;\n\nfunction parseDocType(globalObject, ownerDocument, html) {\n  if (HTML5_DOCTYPE.test(html)) {\n    return createDocumentType(globalObject, ownerDocument, \"html\", \"\", \"\");\n  }\n\n  var publicPieces = PUBLIC_DOCTYPE.exec(html);\n\n  if (publicPieces) {\n    return createDocumentType(globalObject, ownerDocument, publicPieces[1], publicPieces[2], publicPieces[3]);\n  }\n\n  var systemPieces = SYSTEM_DOCTYPE.exec(html);\n\n  if (systemPieces) {\n    return createDocumentType(globalObject, ownerDocument, systemPieces[1], \"\", systemPieces[2]);\n  }\n\n  var namePiece = CUSTOM_NAME_DOCTYPE.exec(html)[1] || \"html\";\n  return createDocumentType(globalObject, ownerDocument, namePiece, \"\", \"\");\n}\n\nfunction createDocumentType(globalObject, ownerDocument, name, publicId, systemId) {\n  return DocumentType.createImpl(globalObject, [], {\n    ownerDocument: ownerDocument,\n    name: name,\n    publicId: publicId,\n    systemId: systemId\n  });\n}\n\nfunction isHTMLTemplateElement(element) {\n  return element.tagName === \"template\" && element.namespaceURI === HTML_NS;\n}\n\nfunction createParser(rootNode, globalObject, saxesOptions) {\n  var parser = new SaxesParser(_objectSpread(_objectSpread({}, saxesOptions), {}, {\n    // Browsers always have namespace support.\n    xmlns: true,\n    // We force the parser to treat all documents (even documents declaring themselves to be XML 1.1 documents) as XML\n    // 1.0 documents. See https://github.com/jsdom/jsdom/issues/2677 for a discussion of the stakes.\n    defaultXMLVersion: \"1.0\",\n    forceXMLVersion: true\n  }));\n  var openStack = [rootNode];\n\n  function getOwnerDocument() {\n    var currentElement = openStack[openStack.length - 1];\n    return isHTMLTemplateElement(currentElement) ? currentElement._templateContents._ownerDocument : currentElement._ownerDocument;\n  }\n\n  function appendChild(child) {\n    var parentElement = openStack[openStack.length - 1];\n\n    if (isHTMLTemplateElement(parentElement)) {\n      parentElement._templateContents._insert(child, null);\n    } else {\n      parentElement._insert(child, null);\n    }\n  }\n\n  parser.on(\"text\", saxesOptions.fragment ? // In a fragment, all text events produced by saxes must result in a text\n  // node.\n  function (data) {\n    var ownerDocument = getOwnerDocument();\n    appendChild(Text.createImpl(globalObject, [], {\n      data: data,\n      ownerDocument: ownerDocument\n    }));\n  } : // When parsing a whole document, we must ignore those text nodes that are\n  // produced outside the root element. Saxes produces events for them,\n  // but DOM trees do not record text outside the root element.\n  function (data) {\n    if (openStack.length > 1) {\n      var ownerDocument = getOwnerDocument();\n      appendChild(Text.createImpl(globalObject, [], {\n        data: data,\n        ownerDocument: ownerDocument\n      }));\n    }\n  });\n  parser.on(\"cdata\", function (data) {\n    var ownerDocument = getOwnerDocument();\n    appendChild(CDATASection.createImpl(globalObject, [], {\n      data: data,\n      ownerDocument: ownerDocument\n    }));\n  });\n  parser.on(\"opentag\", function (tag) {\n    var tagLocal = tag.local,\n        tagAttributes = tag.attributes;\n    var ownerDocument = getOwnerDocument();\n    var tagNamespace = tag.uri === \"\" ? null : tag.uri;\n    var tagPrefix = tag.prefix === \"\" ? null : tag.prefix;\n    var isValue = tagAttributes.is === undefined ? null : tagAttributes.is.value;\n    var elem = createElement(ownerDocument, tagLocal, tagNamespace, tagPrefix, isValue, true); // We mark a script element as \"parser-inserted\", which prevents it from\n    // being immediately executed.\n\n    if (tagLocal === \"script\" && tagNamespace === HTML_NS) {\n      elem._parserInserted = true;\n    }\n\n    for (var _i = 0, _Object$keys = Object.keys(tagAttributes); _i < _Object$keys.length; _i++) {\n      var key = _Object$keys[_i];\n      var _tagAttributes$key = tagAttributes[key],\n          prefix = _tagAttributes$key.prefix,\n          local = _tagAttributes$key.local,\n          uri = _tagAttributes$key.uri,\n          value = _tagAttributes$key.value;\n      attributes.setAttributeValue(elem, local, value, prefix === \"\" ? null : prefix, uri === \"\" ? null : uri);\n    }\n\n    appendChild(elem);\n    openStack.push(elem);\n  });\n  parser.on(\"closetag\", function () {\n    var elem = openStack.pop(); // Once a script is populated, we can execute it.\n\n    if (elem.localName === \"script\" && elem.namespaceURI === HTML_NS) {\n      elem._eval();\n    }\n  });\n  parser.on(\"comment\", function (data) {\n    var ownerDocument = getOwnerDocument();\n    appendChild(Comment.createImpl(globalObject, [], {\n      data: data,\n      ownerDocument: ownerDocument\n    }));\n  });\n  parser.on(\"processinginstruction\", function (_ref) {\n    var target = _ref.target,\n        body = _ref.body;\n    var ownerDocument = getOwnerDocument();\n    appendChild(ProcessingInstruction.createImpl(globalObject, [], {\n      target: target,\n      data: body,\n      ownerDocument: ownerDocument\n    }));\n  });\n  parser.on(\"doctype\", function (dt) {\n    var ownerDocument = getOwnerDocument();\n    appendChild(parseDocType(globalObject, ownerDocument, \"<!doctype \".concat(dt, \">\")));\n    var entityMatcher = /<!ENTITY ([^ ]+) \"([^\"]+)\">/g;\n    var result;\n\n    while (result = entityMatcher.exec(dt)) {\n      var _result = result,\n          _result2 = _slicedToArray(_result, 3),\n          name = _result2[1],\n          value = _result2[2];\n\n      if (!(name in parser.ENTITIES)) {\n        parser.ENTITIES[name] = value;\n      }\n    }\n  });\n  parser.on(\"error\", function (err) {\n    throw DOMException.create(globalObject, [err.message, \"SyntaxError\"]);\n  });\n  return parser;\n}\n\nfunction parseFragment(markup, contextElement) {\n  var _globalObject = contextElement._globalObject,\n      _ownerDocument = contextElement._ownerDocument;\n  var fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: _ownerDocument\n  }); // Only parseFragment needs resolvePrefix per the saxes documentation:\n  // https://github.com/lddubeau/saxes#parsing-xml-fragments\n\n  var parser = createParser(fragment, _globalObject, {\n    fragment: true,\n    resolvePrefix: function resolvePrefix(prefix) {\n      // saxes wants undefined as the return value if the prefix is not defined, not null.\n      return contextElement.lookupNamespaceURI(prefix) || undefined;\n    }\n  });\n  parser.write(markup).close();\n  return fragment;\n}\n\nfunction parseIntoDocument(markup, ownerDocument) {\n  var _globalObject = ownerDocument._globalObject;\n  var parser = createParser(ownerDocument, _globalObject, {\n    fileName: ownerDocument.location && ownerDocument.location.href\n  });\n  parser.write(markup).close();\n  return ownerDocument;\n}\n\nmodule.exports = {\n  parseFragment: parseFragment,\n  parseIntoDocument: parseIntoDocument\n};","map":null,"metadata":{},"sourceType":"script"}