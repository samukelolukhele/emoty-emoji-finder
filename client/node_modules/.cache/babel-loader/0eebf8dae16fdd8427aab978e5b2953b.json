{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/createClass\");\n\nvar webIDLConversions = require(\"webidl-conversions\");\n\nvar DOMException = require(\"domexception/webidl2js-wrapper\");\n\nvar NODE_TYPE = require(\"../node-type\");\n\nvar _require = require(\"../helpers/namespaces\"),\n    HTML_NS = _require.HTML_NS;\n\nvar _require2 = require(\"../helpers/create-element\"),\n    getHTMLElementInterface = _require2.getHTMLElementInterface;\n\nvar _require3 = require(\"../helpers/shadow-dom\"),\n    shadowIncludingInclusiveDescendantsIterator = _require3.shadowIncludingInclusiveDescendantsIterator;\n\nvar _require4 = require(\"../helpers/custom-elements\"),\n    isValidCustomElementName = _require4.isValidCustomElementName,\n    tryUpgradeElement = _require4.tryUpgradeElement,\n    enqueueCEUpgradeReaction = _require4.enqueueCEUpgradeReaction;\n\nvar idlUtils = require(\"../generated/utils\");\n\nvar IDLFunction = require(\"../generated/Function.js\");\n\nvar HTMLUnknownElement = require(\"../generated/HTMLUnknownElement\");\n\nvar LIFECYCLE_CALLBACKS = [\"connectedCallback\", \"disconnectedCallback\", \"adoptedCallback\", \"attributeChangedCallback\"];\n\nfunction convertToSequenceDOMString(obj) {\n  if (!obj || !obj[Symbol.iterator]) {\n    throw new TypeError(\"Invalid Sequence\");\n  }\n\n  return Array.from(obj).map(webIDLConversions.DOMString);\n} // Returns true is the passed value is a valid constructor.\n// Borrowed from: https://stackoverflow.com/a/39336206/3832710\n\n\nfunction isConstructor(value) {\n  if (typeof value !== \"function\") {\n    return false;\n  }\n\n  try {\n    var P = new Proxy(value, {\n      construct: function construct() {\n        return {};\n      }\n    }); // eslint-disable-next-line no-new\n\n    new P();\n    return true;\n  } catch (_unused) {\n    return false;\n  }\n} // https://html.spec.whatwg.org/#customelementregistry\n\n\nvar CustomElementRegistryImpl = /*#__PURE__*/function () {\n  function CustomElementRegistryImpl(globalObject) {\n    _classCallCheck(this, CustomElementRegistryImpl);\n\n    this._customElementDefinitions = [];\n    this._elementDefinitionIsRunning = false;\n    this._whenDefinedPromiseMap = Object.create(null);\n    this._globalObject = globalObject;\n  } // https://html.spec.whatwg.org/#dom-customelementregistry-define\n\n\n  _createClass(CustomElementRegistryImpl, [{\n    key: \"define\",\n    value: function define(name, constructor, options) {\n      var _globalObject = this._globalObject;\n      var ctor = constructor.objectReference;\n\n      if (!isConstructor(ctor)) {\n        throw new TypeError(\"Constructor argument is not a constructor.\");\n      }\n\n      if (!isValidCustomElementName(name)) {\n        throw DOMException.create(_globalObject, [\"Name argument is not a valid custom element name.\", \"SyntaxError\"]);\n      }\n\n      var nameAlreadyRegistered = this._customElementDefinitions.some(function (entry) {\n        return entry.name === name;\n      });\n\n      if (nameAlreadyRegistered) {\n        throw DOMException.create(_globalObject, [\"This name has already been registered in the registry.\", \"NotSupportedError\"]);\n      }\n\n      var ctorAlreadyRegistered = this._customElementDefinitions.some(function (entry) {\n        return entry.objectReference === ctor;\n      });\n\n      if (ctorAlreadyRegistered) {\n        throw DOMException.create(_globalObject, [\"This constructor has already been registered in the registry.\", \"NotSupportedError\"]);\n      }\n\n      var localName = name;\n      var extendsOption = null;\n\n      if (options !== undefined && options.extends) {\n        extendsOption = options.extends;\n      }\n\n      if (extendsOption !== null) {\n        if (isValidCustomElementName(extendsOption)) {\n          throw DOMException.create(_globalObject, [\"Option extends value can't be a valid custom element name.\", \"NotSupportedError\"]);\n        }\n\n        var extendsInterface = getHTMLElementInterface(extendsOption);\n\n        if (extendsInterface === HTMLUnknownElement) {\n          throw DOMException.create(_globalObject, [\"\".concat(extendsOption, \" is an HTMLUnknownElement.\"), \"NotSupportedError\"]);\n        }\n\n        localName = extendsOption;\n      }\n\n      if (this._elementDefinitionIsRunning) {\n        throw DOMException.create(_globalObject, [\"Invalid nested custom element definition.\", \"NotSupportedError\"]);\n      }\n\n      this._elementDefinitionIsRunning = true;\n      var disableShadow = false;\n      var observedAttributes = [];\n      var lifecycleCallbacks = {\n        connectedCallback: null,\n        disconnectedCallback: null,\n        adoptedCallback: null,\n        attributeChangedCallback: null\n      };\n      var caughtError;\n\n      try {\n        var prototype = ctor.prototype;\n\n        if (typeof prototype !== \"object\") {\n          throw new TypeError(\"Invalid constructor prototype.\");\n        }\n\n        var _iterator = _createForOfIteratorHelper(LIFECYCLE_CALLBACKS),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var callbackName = _step.value;\n            var callbackValue = prototype[callbackName];\n\n            if (callbackValue !== undefined) {\n              lifecycleCallbacks[callbackName] = IDLFunction.convert(callbackValue, {\n                context: \"The lifecycle callback \\\"\".concat(callbackName, \"\\\"\")\n              });\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (lifecycleCallbacks.attributeChangedCallback !== null) {\n          var observedAttributesIterable = ctor.observedAttributes;\n\n          if (observedAttributesIterable !== undefined) {\n            observedAttributes = convertToSequenceDOMString(observedAttributesIterable);\n          }\n        }\n\n        var disabledFeatures = [];\n        var disabledFeaturesIterable = ctor.disabledFeatures;\n\n        if (disabledFeaturesIterable) {\n          disabledFeatures = convertToSequenceDOMString(disabledFeaturesIterable);\n        }\n\n        disableShadow = disabledFeatures.includes(\"shadow\");\n      } catch (err) {\n        caughtError = err;\n      } finally {\n        this._elementDefinitionIsRunning = false;\n      }\n\n      if (caughtError !== undefined) {\n        throw caughtError;\n      }\n\n      var definition = {\n        name: name,\n        localName: localName,\n        constructor: constructor,\n        objectReference: ctor,\n        observedAttributes: observedAttributes,\n        lifecycleCallbacks: lifecycleCallbacks,\n        disableShadow: disableShadow,\n        constructionStack: []\n      };\n\n      this._customElementDefinitions.push(definition);\n\n      var document = idlUtils.implForWrapper(this._globalObject._document);\n      var upgradeCandidates = [];\n\n      var _iterator2 = _createForOfIteratorHelper(shadowIncludingInclusiveDescendantsIterator(document)),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var candidate = _step2.value;\n\n          if (candidate._namespaceURI === HTML_NS && candidate._localName === localName && (extendsOption === null || candidate._isValue === name)) {\n            upgradeCandidates.push(candidate);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      for (var _i = 0, _upgradeCandidates = upgradeCandidates; _i < _upgradeCandidates.length; _i++) {\n        var upgradeCandidate = _upgradeCandidates[_i];\n        enqueueCEUpgradeReaction(upgradeCandidate, definition);\n      }\n\n      if (this._whenDefinedPromiseMap[name] !== undefined) {\n        this._whenDefinedPromiseMap[name].resolve(ctor);\n\n        delete this._whenDefinedPromiseMap[name];\n      }\n    } // https://html.spec.whatwg.org/#dom-customelementregistry-get\n\n  }, {\n    key: \"get\",\n    value: function get(name) {\n      var definition = this._customElementDefinitions.find(function (entry) {\n        return entry.name === name;\n      });\n\n      return definition && definition.objectReference;\n    } // https://html.spec.whatwg.org/#dom-customelementregistry-whendefined\n\n  }, {\n    key: \"whenDefined\",\n    value: function whenDefined(name) {\n      if (!isValidCustomElementName(name)) {\n        return Promise.reject(DOMException.create(this._globalObject, [\"Name argument is not a valid custom element name.\", \"SyntaxError\"]));\n      }\n\n      var alreadyRegistered = this._customElementDefinitions.find(function (entry) {\n        return entry.name === name;\n      });\n\n      if (alreadyRegistered) {\n        return Promise.resolve(alreadyRegistered.objectReference);\n      }\n\n      if (this._whenDefinedPromiseMap[name] === undefined) {\n        var resolve;\n        var promise = new Promise(function (r) {\n          resolve = r;\n        }); // Store the pending Promise along with the extracted resolve callback to actually resolve the returned Promise,\n        // once the custom element is registered.\n\n        this._whenDefinedPromiseMap[name] = {\n          promise: promise,\n          resolve: resolve\n        };\n      }\n\n      return this._whenDefinedPromiseMap[name].promise;\n    } // https://html.spec.whatwg.org/#dom-customelementregistry-upgrade\n\n  }, {\n    key: \"upgrade\",\n    value: function upgrade(root) {\n      var _iterator3 = _createForOfIteratorHelper(shadowIncludingInclusiveDescendantsIterator(root)),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var candidate = _step3.value;\n\n          if (candidate.nodeType === NODE_TYPE.ELEMENT_NODE) {\n            tryUpgradeElement(candidate);\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }]);\n\n  return CustomElementRegistryImpl;\n}();\n\nmodule.exports = {\n  implementation: CustomElementRegistryImpl\n};","map":null,"metadata":{},"sourceType":"script"}