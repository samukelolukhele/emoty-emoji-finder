{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/createClass\");\n\nvar DOMException = require(\"domexception/webidl2js-wrapper\");\n\nvar isPotentialCustomElementName = require(\"is-potential-custom-element-name\");\n\nvar NODE_TYPE = require(\"../node-type\");\n\nvar _require = require(\"./namespaces\"),\n    HTML_NS = _require.HTML_NS;\n\nvar _require2 = require(\"./shadow-dom\"),\n    shadowIncludingRoot = _require2.shadowIncludingRoot;\n\nvar reportException = require(\"./runtime-script-errors\");\n\nvar _require3 = require(\"../generated/utils\"),\n    implForWrapper = _require3.implForWrapper,\n    wrapperForImpl = _require3.wrapperForImpl; // https://html.spec.whatwg.org/multipage/custom-elements.html#custom-element-reactions-stack\n\n\nvar CEReactionsStack = /*#__PURE__*/function () {\n  function CEReactionsStack() {\n    _classCallCheck(this, CEReactionsStack);\n\n    this._stack = []; // https://html.spec.whatwg.org/multipage/custom-elements.html#backup-element-queue\n\n    this.backupElementQueue = []; // https://html.spec.whatwg.org/multipage/custom-elements.html#processing-the-backup-element-queue\n\n    this.processingBackupElementQueue = false;\n  }\n\n  _createClass(CEReactionsStack, [{\n    key: \"push\",\n    value: function push(elementQueue) {\n      this._stack.push(elementQueue);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      return this._stack.pop();\n    }\n  }, {\n    key: \"currentElementQueue\",\n    get: function get() {\n      var _stack = this._stack;\n      return _stack[_stack.length - 1];\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this._stack.length === 0;\n    }\n  }]);\n\n  return CEReactionsStack;\n}(); // In theory separate cross-origin Windows created by separate JSDOM instances could have separate stacks. But, we would\n// need to implement the whole agent architecture. Which is kind of questionable given that we don't run our Windows in\n// their own separate threads, which is what agents are meant to represent.\n\n\nvar customElementReactionsStack = new CEReactionsStack(); // https://html.spec.whatwg.org/multipage/custom-elements.html#cereactions\n\nfunction ceReactionsPreSteps() {\n  customElementReactionsStack.push([]);\n}\n\nfunction ceReactionsPostSteps() {\n  var queue = customElementReactionsStack.pop();\n  invokeCEReactions(queue);\n}\n\nvar RESTRICTED_CUSTOM_ELEMENT_NAME = new Set([\"annotation-xml\", \"color-profile\", \"font-face\", \"font-face-src\", \"font-face-uri\", \"font-face-format\", \"font-face-name\", \"missing-glyph\"]); // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\n\nfunction isValidCustomElementName(name) {\n  if (RESTRICTED_CUSTOM_ELEMENT_NAME.has(name)) {\n    return false;\n  }\n\n  return isPotentialCustomElementName(name);\n} // https://html.spec.whatwg.org/multipage/custom-elements.html#concept-upgrade-an-element\n\n\nfunction upgradeElement(definition, element) {\n  if (element._ceState !== \"undefined\" || element._ceState === \"uncustomized\") {\n    return;\n  }\n\n  element._ceDefinition = definition;\n  element._ceState = \"failed\";\n\n  var _iterator = _createForOfIteratorHelper(element._attributeList),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var attribute = _step.value;\n      var _localName = attribute._localName,\n          _namespace = attribute._namespace,\n          _value = attribute._value;\n      enqueueCECallbackReaction(element, \"attributeChangedCallback\", [_localName, null, _value, _namespace]);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (shadowIncludingRoot(element).nodeType === NODE_TYPE.DOCUMENT_NODE) {\n    enqueueCECallbackReaction(element, \"connectedCallback\", []);\n  }\n\n  definition.constructionStack.push(element);\n  var constructionStack = definition.constructionStack,\n      C = definition.constructor;\n  var constructionError;\n\n  try {\n    if (definition.disableShadow === true && element._shadowRoot !== null) {\n      throw DOMException.create(element._globalObject, [\"Can't upgrade a custom element with a shadow root if shadow is disabled\", \"NotSupportedError\"]);\n    }\n\n    var constructionResult = C.construct();\n    var constructionResultImpl = implForWrapper(constructionResult);\n\n    if (constructionResultImpl !== element) {\n      throw new TypeError(\"Invalid custom element constructor return value\");\n    }\n  } catch (error) {\n    constructionError = error;\n  }\n\n  constructionStack.pop();\n\n  if (constructionError !== undefined) {\n    element._ceDefinition = null;\n    element._ceReactionQueue = [];\n    throw constructionError;\n  }\n\n  element._ceState = \"custom\";\n} // https://html.spec.whatwg.org/#concept-try-upgrade\n\n\nfunction tryUpgradeElement(element) {\n  var _ownerDocument = element._ownerDocument,\n      _namespaceURI = element._namespaceURI,\n      _localName = element._localName,\n      _isValue = element._isValue;\n  var definition = lookupCEDefinition(_ownerDocument, _namespaceURI, _localName, _isValue);\n\n  if (definition !== null) {\n    enqueueCEUpgradeReaction(element, definition);\n  }\n} // https://html.spec.whatwg.org/#look-up-a-custom-element-definition\n\n\nfunction lookupCEDefinition(document, namespace, localName, isValue) {\n  var definition = null;\n\n  if (namespace !== HTML_NS) {\n    return definition;\n  }\n\n  if (!document._defaultView) {\n    return definition;\n  }\n\n  var registry = implForWrapper(document._globalObject.customElements);\n\n  var definitionByName = registry._customElementDefinitions.find(function (def) {\n    return def.name === def.localName && def.localName === localName;\n  });\n\n  if (definitionByName !== undefined) {\n    return definitionByName;\n  }\n\n  var definitionByIs = registry._customElementDefinitions.find(function (def) {\n    return def.name === isValue && def.localName === localName;\n  });\n\n  if (definitionByIs !== undefined) {\n    return definitionByIs;\n  }\n\n  return definition;\n} // https://html.spec.whatwg.org/multipage/custom-elements.html#invoke-custom-element-reactions\n\n\nfunction invokeCEReactions(elementQueue) {\n  while (elementQueue.length > 0) {\n    var element = elementQueue.shift();\n    var reactions = element._ceReactionQueue;\n\n    try {\n      while (reactions.length > 0) {\n        var reaction = reactions.shift();\n\n        switch (reaction.type) {\n          case \"upgrade\":\n            upgradeElement(reaction.definition, element);\n            break;\n\n          case \"callback\":\n            reaction.callback.apply(wrapperForImpl(element), reaction.args);\n            break;\n        }\n      }\n    } catch (error) {\n      reportException(element._globalObject, error);\n    }\n  }\n} // https://html.spec.whatwg.org/multipage/custom-elements.html#enqueue-an-element-on-the-appropriate-element-queue\n\n\nfunction enqueueElementOnAppropriateElementQueue(element) {\n  if (customElementReactionsStack.isEmpty()) {\n    customElementReactionsStack.backupElementQueue.push(element);\n\n    if (customElementReactionsStack.processingBackupElementQueue) {\n      return;\n    }\n\n    customElementReactionsStack.processingBackupElementQueue = true;\n    Promise.resolve().then(function () {\n      var elementQueue = customElementReactionsStack.backupElementQueue;\n      invokeCEReactions(elementQueue);\n      customElementReactionsStack.processingBackupElementQueue = false;\n    });\n  } else {\n    customElementReactionsStack.currentElementQueue.push(element);\n  }\n} // https://html.spec.whatwg.org/multipage/custom-elements.html#enqueue-a-custom-element-callback-reaction\n\n\nfunction enqueueCECallbackReaction(element, callbackName, args) {\n  var _element$_ceDefinitio = element._ceDefinition,\n      lifecycleCallbacks = _element$_ceDefinitio.lifecycleCallbacks,\n      observedAttributes = _element$_ceDefinitio.observedAttributes;\n  var callback = lifecycleCallbacks[callbackName];\n\n  if (callback === null) {\n    return;\n  }\n\n  if (callbackName === \"attributeChangedCallback\") {\n    var attributeName = args[0];\n\n    if (!observedAttributes.includes(attributeName)) {\n      return;\n    }\n  }\n\n  element._ceReactionQueue.push({\n    type: \"callback\",\n    callback: callback,\n    args: args\n  });\n\n  enqueueElementOnAppropriateElementQueue(element);\n} // https://html.spec.whatwg.org/#enqueue-a-custom-element-upgrade-reaction\n\n\nfunction enqueueCEUpgradeReaction(element, definition) {\n  element._ceReactionQueue.push({\n    type: \"upgrade\",\n    definition: definition\n  });\n\n  enqueueElementOnAppropriateElementQueue(element);\n}\n\nmodule.exports = {\n  customElementReactionsStack: customElementReactionsStack,\n  ceReactionsPreSteps: ceReactionsPreSteps,\n  ceReactionsPostSteps: ceReactionsPostSteps,\n  isValidCustomElementName: isValidCustomElementName,\n  upgradeElement: upgradeElement,\n  tryUpgradeElement: tryUpgradeElement,\n  lookupCEDefinition: lookupCEDefinition,\n  enqueueCEUpgradeReaction: enqueueCEUpgradeReaction,\n  enqueueCECallbackReaction: enqueueCECallbackReaction,\n  invokeCEReactions: invokeCEReactions\n};","map":null,"metadata":{},"sourceType":"script"}