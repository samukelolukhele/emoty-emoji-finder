{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar http = require(\"http\");\n\nvar https = require(\"https\");\n\nvar _require = require(\"stream\"),\n    Writable = _require.Writable;\n\nvar zlib = require(\"zlib\");\n\nvar ver = process.version.replace(\"v\", \"\").split(\".\");\nvar majorNodeVersion = Number.parseInt(ver[0]);\n\nfunction abortRequest(clientRequest) {\n  // clientRequest.destroy breaks the test suite for versions 10 and 12,\n  // hence the version check\n  if (majorNodeVersion > 13) {\n    clientRequest.destroy();\n  } else {\n    clientRequest.abort();\n  }\n\n  clientRequest.removeAllListeners();\n  clientRequest.on(\"error\", function () {});\n}\n\nmodule.exports = /*#__PURE__*/function (_Writable) {\n  _inherits(Request, _Writable);\n\n  var _super = _createSuper(Request);\n\n  function Request(url, clientOptions, requestOptions) {\n    var _this;\n\n    _classCallCheck(this, Request);\n\n    _this = _super.call(this);\n    Object.assign(_assertThisInitialized(_this), clientOptions);\n    _this.currentURL = url;\n    _this._requestOptions = requestOptions;\n    _this.headers = requestOptions.headers;\n    _this._ended = false;\n    _this._redirectCount = 0;\n    _this._requestBodyBuffers = [];\n    _this._bufferIndex = 0;\n\n    _this._performRequest();\n\n    return _this;\n  }\n\n  _createClass(Request, [{\n    key: \"abort\",\n    value: function abort() {\n      abortRequest(this._currentRequest);\n      this.emit(\"abort\");\n      this.removeAllListeners();\n    }\n  }, {\n    key: \"pipeRequest\",\n    value: function pipeRequest(form) {\n      form.pipe(this._currentRequest);\n    }\n  }, {\n    key: \"write\",\n    value: function write(data, encoding) {\n      if (data.length > 0) {\n        this._requestBodyBuffers.push({\n          data: data,\n          encoding: encoding\n        });\n\n        this._currentRequest.write(data, encoding);\n      }\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      this.emit(\"request\", this._currentRequest);\n      this._ended = true;\n\n      this._currentRequest.end();\n    }\n  }, {\n    key: \"setHeader\",\n    value: function setHeader(name, value) {\n      this.headers[name] = value;\n\n      this._currentRequest.setHeader(name, value);\n    }\n  }, {\n    key: \"removeHeader\",\n    value: function removeHeader(name) {\n      delete this.headers[name];\n\n      this._currentRequest.removeHeader(name);\n    } // Without this method, the test send-redirect-infinite-sync will halt the test suite\n    // TODO: investigate this further and ideally remove\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var _this$_requestOptions = this._requestOptions,\n          method = _this$_requestOptions.method,\n          headers = _this$_requestOptions.headers;\n      return {\n        uri: new URL(this.currentURL),\n        method: method,\n        headers: headers\n      };\n    }\n  }, {\n    key: \"_writeNext\",\n    value: function _writeNext(error) {\n      if (this._currentRequest) {\n        if (error) {\n          this.emit(\"error\", error);\n        } else if (this._bufferIndex < this._requestBodyBuffers.length) {\n          var buffer = this._requestBodyBuffers[this._bufferIndex++];\n\n          if (!this._currentRequest.writableEnded) {\n            this._currentRequest.write(buffer.data, buffer.encoding, this._writeNext.bind(this));\n          }\n        } else if (this._ended) {\n          this._currentRequest.end();\n        }\n      }\n    }\n  }, {\n    key: \"_performRequest\",\n    value: function _performRequest() {\n      var _this2 = this;\n\n      var urlOptions = new URL(this.currentURL);\n      var scheme = urlOptions.protocol;\n      this._requestOptions.agent = this.agents[scheme.substring(0, scheme.length - 1)];\n\n      var _ref = scheme === \"https:\" ? https : http,\n          request = _ref.request;\n\n      this._currentRequest = request(this.currentURL, this._requestOptions, function (response) {\n        _this2._processResponse(response);\n      });\n      var cookies;\n\n      if (this._redirectCount === 0) {\n        this.originalCookieHeader = this.getHeader(\"Cookie\");\n      }\n\n      if (this.cookieJar) {\n        cookies = this.cookieJar.getCookieStringSync(this.currentURL);\n      }\n\n      if (cookies && cookies.length) {\n        if (this.originalCookieHeader) {\n          this.setHeader(\"Cookie\", this.originalCookieHeader + \"; \" + cookies);\n        } else {\n          this.setHeader(\"Cookie\", cookies);\n        }\n      }\n\n      var _loop = function _loop() {\n        var event = _arr[_i];\n\n        _this2._currentRequest.on(event, function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          _this2.emit.apply(_this2, [event].concat(args));\n        });\n      };\n\n      for (var _i = 0, _arr = [\"connect\", \"error\", \"socket\", \"timeout\"]; _i < _arr.length; _i++) {\n        _loop();\n      }\n\n      if (this._isRedirect) {\n        this._bufferIndex = 0;\n\n        this._writeNext();\n      }\n    }\n  }, {\n    key: \"_processResponse\",\n    value: function _processResponse(response) {\n      var _this3 = this;\n\n      var cookies = response.headers[\"set-cookie\"];\n\n      if (this.cookieJar && Array.isArray(cookies)) {\n        try {\n          cookies.forEach(function (cookie) {\n            _this3.cookieJar.setCookieSync(cookie, _this3.currentURL, {\n              ignoreError: true\n            });\n          });\n        } catch (e) {\n          this.emit(\"error\", e);\n        }\n      }\n\n      var statusCode = response.statusCode;\n      var location = response.headers.location; // In Node v15, aborting a message with remaining data causes an error to be thrown,\n      // hence the version check\n\n      var catchResErrors = function catchResErrors(err) {\n        if (!(majorNodeVersion >= 15 && err.message === \"aborted\")) {\n          _this3.emit(\"error\", err);\n        }\n      };\n\n      response.on(\"error\", catchResErrors);\n      var redirectAddress = null;\n      var resendWithAuth = false;\n\n      if (typeof location === \"string\" && location.length && this.followRedirects && statusCode >= 300 && statusCode < 400) {\n        redirectAddress = location;\n      } else if (statusCode === 401 && /^Basic /i.test(response.headers[\"www-authenticate\"] || \"\") && this.user && this.user.length) {\n        this._requestOptions.auth = \"\".concat(this.user, \":\").concat(this.pass);\n        resendWithAuth = true;\n      }\n\n      if (redirectAddress || resendWithAuth) {\n        if (++this._redirectCount > 21) {\n          var redirectError = new Error(\"Maximum number of redirects exceeded\");\n          redirectError.code = \"ERR_TOO_MANY_REDIRECTS\";\n          this.emit(\"error\", redirectError);\n          return;\n        }\n\n        abortRequest(this._currentRequest);\n        response.destroy();\n        this._isRedirect = true;\n\n        if ((statusCode === 301 || statusCode === 302) && this._requestOptions.method === \"POST\" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._requestOptions.method)) {\n          this._requestOptions.method = \"GET\";\n          this._requestBodyBuffers = [];\n        }\n\n        var previousHostName = this._removeMatchingHeaders(/^host$/i);\n\n        if (!previousHostName) {\n          previousHostName = new URL(this.currentURL).hostname;\n        }\n\n        var previousURL = this.currentURL;\n\n        if (!resendWithAuth) {\n          var nextURL = redirectAddress.startsWith(\"https:\") ? new URL(redirectAddress) : new URL(redirectAddress, this.currentURL);\n\n          if (nextURL.hostname !== previousHostName) {\n            this._removeMatchingHeaders(/^authorization$/i);\n          }\n\n          this.currentURL = nextURL.toString();\n        }\n\n        this.headers.Referer = previousURL;\n        this.emit(\"redirect\", response, this.headers, this.currentURL);\n\n        try {\n          this._performRequest();\n        } catch (cause) {\n          this.emit(\"error\", cause);\n        }\n      } else {\n        var pipeline = response;\n        var acceptEncoding = this.headers[\"Accept-Encoding\"];\n        var requestCompressed = typeof acceptEncoding === \"string\" && (acceptEncoding.includes(\"gzip\") || acceptEncoding.includes(\"deflate\"));\n\n        if (requestCompressed && this._requestOptions.method !== \"HEAD\" && statusCode >= 200 && statusCode !== 204 && statusCode !== 304) {\n          var zlibOptions = {\n            flush: zlib.constants.Z_SYNC_FLUSH,\n            finishFlush: zlib.constants.Z_SYNC_FLUSH\n          };\n          var contentEncoding = (response.headers[\"content-encoding\"] || \"identity\").trim().toLowerCase();\n\n          if (contentEncoding === \"gzip\") {\n            pipeline = zlib.createGunzip(zlibOptions);\n            response.pipe(pipeline);\n          } else if (contentEncoding === \"deflate\") {\n            pipeline = zlib.createInflate(zlibOptions);\n            response.pipe(pipeline);\n          }\n        }\n\n        pipeline.removeAllListeners(\"error\");\n        this.emit(\"response\", response, this.currentURL);\n        pipeline.on(\"data\", function (bytes) {\n          return _this3.emit(\"data\", bytes);\n        });\n        pipeline.once(\"end\", function (bytes) {\n          return _this3.emit(\"end\", bytes);\n        });\n        pipeline.on(\"error\", catchResErrors);\n        pipeline.on(\"close\", function () {\n          return _this3.emit(\"close\");\n        });\n        this._requestBodyBuffers = [];\n      }\n    }\n  }, {\n    key: \"getHeader\",\n    value: function getHeader(key, value) {\n      if (this._currentRequest) {\n        return this._currentRequest.getHeader(key, value);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_removeMatchingHeaders\",\n    value: function _removeMatchingHeaders(regex) {\n      var lastValue;\n\n      for (var header in this.headers) {\n        if (regex.test(header)) {\n          lastValue = this.headers[header];\n          delete this.headers[header];\n        }\n      }\n\n      return lastValue;\n    }\n  }]);\n\n  return Request;\n}(Writable);","map":null,"metadata":{},"sourceType":"script"}