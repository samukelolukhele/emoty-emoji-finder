{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _require = require(\"./internal-constants\"),\n    domSymbolTree = _require.domSymbolTree;\n\nvar reportException = require(\"./runtime-script-errors\");\n\nvar Event = require(\"../generated/Event\");\n\nvar idlUtils = require(\"../generated/utils\");\n\nvar MutationRecord = require(\"../generated/MutationRecord\");\n\nvar MUTATION_TYPE = {\n  ATTRIBUTES: \"attributes\",\n  CHARACTER_DATA: \"characterData\",\n  CHILD_LIST: \"childList\"\n}; // Note:\n// Since jsdom doesn't currently implement the concept of \"unit of related similar-origin browsing contexts\"\n// (https://html.spec.whatwg.org/multipage/browsers.html#unit-of-related-similar-origin-browsing-contexts)\n// we will approximate that the following properties are global for now.\n// https://dom.spec.whatwg.org/#mutation-observer-compound-microtask-queued-flag\n\nvar mutationObserverMicrotaskQueueFlag = false; // Non-spec compliant: List of all the mutation observers with mutation records enqueued. It's a replacement for\n// mutation observer list (https://dom.spec.whatwg.org/#mutation-observer-list) but without leaking since it's empty\n// before notifying the mutation observers.\n\nvar activeMutationObservers = new Set(); // https://dom.spec.whatwg.org/#signal-slot-list\n\nvar signalSlotList = []; // https://dom.spec.whatwg.org/#queue-a-mutation-record\n\nfunction queueMutationRecord(type, target, name, namespace, oldValue, addedNodes, removedNodes, previousSibling, nextSibling) {\n  var interestedObservers = new Map();\n  var nodes = domSymbolTree.ancestorsToArray(target);\n\n  var _iterator = _createForOfIteratorHelper(nodes),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var node = _step.value;\n\n      var _iterator3 = _createForOfIteratorHelper(node._registeredObserverList),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var registered = _step3.value;\n          var options = registered.options,\n              mo = registered.observer;\n\n          if (!(node !== target && options.subtree === false) && !(type === MUTATION_TYPE.ATTRIBUTES && options.attributes !== true) && !(type === MUTATION_TYPE.ATTRIBUTES && options.attributeFilter && !options.attributeFilter.some(function (value) {\n            return value === name || value === namespace;\n          })) && !(type === MUTATION_TYPE.CHARACTER_DATA && options.characterData !== true) && !(type === MUTATION_TYPE.CHILD_LIST && options.childList === false)) {\n            if (!interestedObservers.has(mo)) {\n              interestedObservers.set(mo, null);\n            }\n\n            if (type === MUTATION_TYPE.ATTRIBUTES && options.attributeOldValue === true || type === MUTATION_TYPE.CHARACTER_DATA && options.characterDataOldValue === true) {\n              interestedObservers.set(mo, oldValue);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(interestedObservers.entries()),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n          observer = _step2$value[0],\n          mappedOldValue = _step2$value[1];\n\n      var record = MutationRecord.createImpl(target._globalObject, [], {\n        type: type,\n        target: target,\n        attributeName: name,\n        attributeNamespace: namespace,\n        oldValue: mappedOldValue,\n        addedNodes: addedNodes,\n        removedNodes: removedNodes,\n        previousSibling: previousSibling,\n        nextSibling: nextSibling\n      });\n\n      observer._recordQueue.push(record);\n\n      activeMutationObservers.add(observer);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  queueMutationObserverMicrotask();\n} // https://dom.spec.whatwg.org/#queue-a-tree-mutation-record\n\n\nfunction queueTreeMutationRecord(target, addedNodes, removedNodes, previousSibling, nextSibling) {\n  queueMutationRecord(MUTATION_TYPE.CHILD_LIST, target, null, null, null, addedNodes, removedNodes, previousSibling, nextSibling);\n} // https://dom.spec.whatwg.org/#queue-an-attribute-mutation-record\n\n\nfunction queueAttributeMutationRecord(target, name, namespace, oldValue) {\n  queueMutationRecord(MUTATION_TYPE.ATTRIBUTES, target, name, namespace, oldValue, [], [], null, null);\n} // https://dom.spec.whatwg.org/#queue-a-mutation-observer-compound-microtask\n\n\nfunction queueMutationObserverMicrotask() {\n  if (mutationObserverMicrotaskQueueFlag) {\n    return;\n  }\n\n  mutationObserverMicrotaskQueueFlag = true;\n  Promise.resolve().then(function () {\n    notifyMutationObservers();\n  });\n} // https://dom.spec.whatwg.org/#notify-mutation-observers\n\n\nfunction notifyMutationObservers() {\n  mutationObserverMicrotaskQueueFlag = false;\n\n  var notifyList = _toConsumableArray(activeMutationObservers).sort(function (a, b) {\n    return a._id - b._id;\n  });\n\n  activeMutationObservers.clear();\n  var signalList = [].concat(signalSlotList);\n  signalSlotList.splice(0, signalSlotList.length);\n\n  var _iterator4 = _createForOfIteratorHelper(notifyList),\n      _step4;\n\n  try {\n    var _loop = function _loop() {\n      var mo = _step4.value;\n\n      var records = _toConsumableArray(mo._recordQueue);\n\n      mo._recordQueue = [];\n\n      var _iterator6 = _createForOfIteratorHelper(mo._nodeList),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var node = _step6.value;\n          node._registeredObserverList = node._registeredObserverList.filter(function (registeredObserver) {\n            return registeredObserver.source !== mo;\n          });\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      if (records.length > 0) {\n        try {\n          var moWrapper = idlUtils.wrapperForImpl(mo);\n\n          mo._callback.call(moWrapper, records.map(idlUtils.wrapperForImpl), moWrapper);\n        } catch (e) {\n          var target = records[0].target;\n          var window = target._ownerDocument._defaultView;\n          reportException(window, e);\n        }\n      }\n    };\n\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  var _iterator5 = _createForOfIteratorHelper(signalList),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var slot = _step5.value;\n      var slotChangeEvent = Event.createImpl(slot._globalObject, [\"slotchange\", {\n        bubbles: true\n      }], {\n        isTrusted: true\n      });\n\n      slot._dispatch(slotChangeEvent);\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n}\n\nmodule.exports = {\n  MUTATION_TYPE: MUTATION_TYPE,\n  queueMutationRecord: queueMutationRecord,\n  queueTreeMutationRecord: queueTreeMutationRecord,\n  queueAttributeMutationRecord: queueAttributeMutationRecord,\n  queueMutationObserverMicrotask: queueMutationObserverMicrotask,\n  signalSlotList: signalSlotList\n};","map":null,"metadata":{},"sourceType":"script"}