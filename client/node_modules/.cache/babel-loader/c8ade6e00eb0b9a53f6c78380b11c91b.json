{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar fs = require(\"fs\");\n\nvar _require = require(\"events\"),\n    EventEmitter = _require.EventEmitter;\n\nvar _require2 = require(\"whatwg-url\"),\n    URL = _require2.URL;\n\nvar parseDataURL = require(\"data-urls\");\n\nvar DOMException = require(\"domexception/webidl2js-wrapper\");\n\nvar ProgressEvent = require(\"../generated/ProgressEvent\");\n\nvar agentFactory = require(\"../helpers/agent-factory\");\n\nvar Request = require(\"../helpers/http-request\");\n\nvar FormData = require(\"form-data\");\n\nvar _require3 = require(\"../helpers/events\"),\n    fireAnEvent = _require3.fireAnEvent;\n\nvar headerListSeparatorRegexp = /,[ \\t]*/;\nvar simpleMethods = new Set([\"GET\", \"HEAD\", \"POST\"]);\nvar simpleHeaders = new Set([\"accept\", \"accept-language\", \"content-language\", \"content-type\"]);\nvar preflightHeaders = new Set([\"access-control-expose-headers\", \"access-control-allow-headers\", \"access-control-allow-credentials\", \"access-control-allow-origin\"]);\nvar READY_STATES = exports.READY_STATES = Object.freeze({\n  UNSENT: 0,\n  OPENED: 1,\n  HEADERS_RECEIVED: 2,\n  LOADING: 3,\n  DONE: 4\n});\n\nfunction getRequestHeader(requestHeaders, header) {\n  var lcHeader = header.toLowerCase();\n  var keys = Object.keys(requestHeaders);\n  var n = keys.length;\n\n  while (n--) {\n    var key = keys[n];\n\n    if (key.toLowerCase() === lcHeader) {\n      return requestHeaders[key];\n    }\n  }\n\n  return null;\n}\n\nfunction updateRequestHeader(requestHeaders, header, newValue) {\n  var lcHeader = header.toLowerCase();\n  var keys = Object.keys(requestHeaders);\n  var n = keys.length;\n\n  while (n--) {\n    var key = keys[n];\n\n    if (key.toLowerCase() === lcHeader) {\n      requestHeaders[key] = newValue;\n    }\n  }\n}\n\nfunction dispatchError(xhr) {\n  var errMessage = xhr.properties.error;\n  requestErrorSteps(xhr, \"error\", DOMException.create(xhr._globalObject, [errMessage, \"NetworkError\"]));\n\n  if (xhr._ownerDocument) {\n    var error = new Error(errMessage);\n    error.type = \"XMLHttpRequest\"; // TODO this should become \"resource loading\" when XHR goes through resource loader\n\n    xhr._ownerDocument._defaultView._virtualConsole.emit(\"jsdomError\", error);\n  }\n}\n\nfunction validCORSHeaders(xhr, response, flag, properties, origin) {\n  var acaoStr = response.headers[\"access-control-allow-origin\"];\n  var acao = acaoStr ? acaoStr.trim() : null;\n\n  if (acao !== \"*\" && acao !== origin) {\n    properties.error = \"Cross origin \" + origin + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n\n  var acacStr = response.headers[\"access-control-allow-credentials\"];\n  var acac = acacStr ? acacStr.trim() : null;\n\n  if (flag.withCredentials && acac !== \"true\") {\n    properties.error = \"Credentials forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n\n  return true;\n}\n\nfunction validCORSPreflightHeaders(xhr, response, flag, properties) {\n  if (!validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n    return false;\n  }\n\n  var acahStr = response.headers[\"access-control-allow-headers\"];\n  var acah = new Set(acahStr ? acahStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);\n  var forbiddenHeaders = acah.has(\"*\") ? [] : Object.keys(flag.requestHeaders).filter(function (header) {\n    var lcHeader = header.toLowerCase();\n    return !simpleHeaders.has(lcHeader) && !acah.has(lcHeader);\n  });\n\n  if (forbiddenHeaders.length > 0) {\n    properties.error = \"Headers \" + forbiddenHeaders + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n\n  return true;\n}\n\nfunction requestErrorSteps(xhr, event, exception) {\n  var flag = xhr.flag,\n      properties = xhr.properties,\n      upload = xhr.upload;\n  xhr.readyState = READY_STATES.DONE;\n  properties.send = false;\n  setResponseToNetworkError(xhr);\n\n  if (flag.synchronous) {\n    throw exception;\n  }\n\n  fireAnEvent(\"readystatechange\", xhr);\n\n  if (!properties.uploadComplete) {\n    properties.uploadComplete = true;\n\n    if (properties.uploadListener) {\n      fireAnEvent(event, upload, ProgressEvent, {\n        loaded: 0,\n        total: 0,\n        lengthComputable: false\n      });\n      fireAnEvent(\"loadend\", upload, ProgressEvent, {\n        loaded: 0,\n        total: 0,\n        lengthComputable: false\n      });\n    }\n  }\n\n  fireAnEvent(event, xhr, ProgressEvent, {\n    loaded: 0,\n    total: 0,\n    lengthComputable: false\n  });\n  fireAnEvent(\"loadend\", xhr, ProgressEvent, {\n    loaded: 0,\n    total: 0,\n    lengthComputable: false\n  });\n}\n\nfunction setResponseToNetworkError(xhr) {\n  var properties = xhr.properties;\n  properties.responseBuffer = properties.responseCache = properties.responseTextCache = properties.responseXMLCache = null;\n  properties.responseHeaders = {};\n  xhr.status = 0;\n  xhr.statusText = \"\";\n} // return a \"request\" client object or an event emitter matching the same behaviour for unsupported protocols\n// the callback should be called with a \"request\" response object or an event emitter matching the same behaviour too\n\n\nfunction createClient(xhr) {\n  var flag = xhr.flag,\n      properties = xhr.properties;\n  var urlObj = new URL(flag.uri);\n  var uri = urlObj.href;\n  var ucMethod = flag.method.toUpperCase();\n  var requestManager = flag.requestManager;\n\n  if (urlObj.protocol === \"file:\") {\n    var response = new EventEmitter();\n    response.statusCode = 200;\n    response.rawHeaders = [];\n    response.headers = {};\n    var filePath = urlObj.pathname.replace(/^file:\\/\\//, \"\").replace(/^\\/([a-z]):\\//i, \"$1:/\").replace(/%20/g, \" \");\n\n    var _client = new EventEmitter();\n\n    var readableStream = fs.createReadStream(filePath, {\n      encoding: null\n    });\n    readableStream.on(\"data\", function (chunk) {\n      response.emit(\"data\", chunk);\n\n      _client.emit(\"data\", chunk);\n    });\n    readableStream.on(\"end\", function () {\n      response.emit(\"end\");\n\n      _client.emit(\"end\");\n    });\n    readableStream.on(\"error\", function (err) {\n      _client.emit(\"error\", err);\n    });\n\n    _client.abort = function () {\n      readableStream.destroy();\n\n      _client.emit(\"abort\");\n    };\n\n    if (requestManager) {\n      var req = {\n        abort: function abort() {\n          properties.abortError = true;\n          xhr.abort();\n        }\n      };\n      requestManager.add(req);\n      var rmReq = requestManager.remove.bind(requestManager, req);\n\n      _client.on(\"abort\", rmReq);\n\n      _client.on(\"error\", rmReq);\n\n      _client.on(\"end\", rmReq);\n    }\n\n    process.nextTick(function () {\n      return _client.emit(\"response\", response, urlObj.href);\n    });\n    return _client;\n  }\n\n  if (urlObj.protocol === \"data:\") {\n    var _response = new EventEmitter();\n\n    var _client2 = new EventEmitter();\n\n    var buffer;\n\n    try {\n      var parsed = parseDataURL(uri);\n      var contentType = parsed.mimeType.toString();\n      buffer = Buffer.from(parsed.body);\n      _response.statusCode = 200;\n      _response.rawHeaders = [\"Content-Type\", contentType];\n      _response.headers = {\n        \"content-type\": contentType\n      };\n    } catch (err) {\n      process.nextTick(function () {\n        return _client2.emit(\"error\", err);\n      });\n      return _client2;\n    }\n\n    _client2.abort = function () {// do nothing\n    };\n\n    process.nextTick(function () {\n      _client2.emit(\"response\", _response, urlObj.href);\n\n      process.nextTick(function () {\n        _response.emit(\"data\", buffer);\n\n        _client2.emit(\"data\", buffer);\n\n        _response.emit(\"end\");\n\n        _client2.emit(\"end\");\n      });\n    });\n    return _client2;\n  }\n\n  var agents = agentFactory(flag.proxy, flag.strictSSL);\n  var requestHeaders = {};\n\n  for (var header in flag.requestHeaders) {\n    requestHeaders[header] = flag.requestHeaders[header];\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"referer\") === null) {\n    requestHeaders.Referer = flag.referrer;\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"user-agent\") === null) {\n    requestHeaders[\"User-Agent\"] = flag.userAgent;\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"accept-language\") === null) {\n    requestHeaders[\"Accept-Language\"] = \"en\";\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"accept\") === null) {\n    requestHeaders.Accept = \"*/*\";\n  }\n\n  var crossOrigin = flag.origin !== urlObj.origin;\n\n  if (crossOrigin) {\n    requestHeaders.Origin = flag.origin;\n  }\n\n  var options = {\n    rejectUnauthorized: flag.strictSSL,\n    agents: agents,\n    followRedirects: true\n  };\n\n  if (flag.auth) {\n    options.user = flag.auth.user || \"\";\n    options.pass = flag.auth.pass || \"\";\n  }\n\n  if (flag.cookieJar && (!crossOrigin || flag.withCredentials)) {\n    options.cookieJar = flag.cookieJar;\n  }\n\n  var body = flag.body;\n  var hasBody = body !== undefined && body !== null && body !== \"\" && !(ucMethod === \"HEAD\" || ucMethod === \"GET\");\n\n  if (hasBody && getRequestHeader(flag.requestHeaders, \"content-type\") === null) {\n    requestHeaders[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n  }\n\n  function doRequest() {\n    try {\n      var requestBody = body;\n      var len = 0;\n\n      if (hasBody) {\n        if (flag.formData) {\n          // TODO: implement https://html.spec.whatwg.org/#multipart-form-data\n          // directly instead of using an external library\n          requestBody = new FormData();\n\n          var _iterator = _createForOfIteratorHelper(body),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var entry = _step.value;\n              requestBody.append(entry.name, entry.value, entry.options);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          len = requestBody.getLengthSync();\n          requestHeaders[\"Content-Type\"] = \"multipart/form-data; boundary=\".concat(requestBody.getBoundary());\n        } else {\n          if (typeof body === \"string\") {\n            len = Buffer.byteLength(body);\n          } else {\n            len = body.length;\n          }\n\n          requestBody = Buffer.isBuffer(requestBody) ? requestBody : Buffer.from(requestBody);\n        }\n\n        requestHeaders[\"Content-Length\"] = len;\n      }\n\n      requestHeaders[\"Accept-Encoding\"] = \"gzip, deflate\";\n      var requestClient = new Request(uri, options, {\n        method: flag.method,\n        headers: requestHeaders\n      });\n\n      if (hasBody) {\n        if (flag.formData) {\n          requestBody.on(\"error\", function (err) {\n            requestClient.emit(\"error\", err);\n            requestClient.abort();\n          });\n          requestClient.pipeRequest(requestBody);\n        } else {\n          requestClient.write(requestBody);\n        }\n      }\n\n      return requestClient;\n    } catch (e) {\n      var eventEmitterclient = new EventEmitter();\n      process.nextTick(function () {\n        return eventEmitterclient.emit(\"error\", e);\n      });\n\n      eventEmitterclient.end = function () {};\n\n      return eventEmitterclient;\n    }\n  }\n\n  var client;\n  var nonSimpleHeaders = Object.keys(flag.requestHeaders).filter(function (header) {\n    return !simpleHeaders.has(header.toLowerCase());\n  });\n\n  if (crossOrigin && (!simpleMethods.has(ucMethod) || nonSimpleHeaders.length > 0 || properties.uploadListener)) {\n    client = new EventEmitter();\n    var preflightRequestHeaders = {};\n\n    for (var _header in requestHeaders) {\n      // the only existing request headers the cors spec allows on the preflight request are Origin and Referer\n      var lcHeader = _header.toLowerCase();\n\n      if (lcHeader === \"origin\" || lcHeader === \"referer\") {\n        preflightRequestHeaders[_header] = requestHeaders[_header];\n      }\n    }\n\n    preflightRequestHeaders[\"Access-Control-Request-Method\"] = flag.method;\n\n    if (nonSimpleHeaders.length > 0) {\n      preflightRequestHeaders[\"Access-Control-Request-Headers\"] = nonSimpleHeaders.join(\", \");\n    }\n\n    preflightRequestHeaders[\"User-Agent\"] = flag.userAgent;\n    flag.preflight = true;\n    var rejectUnauthorized = flag.strictSSL;\n    var preflightClient = new Request(uri, {\n      agents: agents,\n      followRedirects: false\n    }, {\n      method: \"OPTIONS\",\n      headers: preflightRequestHeaders,\n      rejectUnauthorized: rejectUnauthorized\n    });\n    preflightClient.on(\"response\", function (resp) {\n      // don't send the real request if the preflight request returned an error\n      if (resp.statusCode < 200 || resp.statusCode > 299) {\n        client.emit(\"error\", new Error(\"Response for preflight has invalid HTTP status code \" + resp.statusCode));\n        return;\n      } // don't send the real request if we aren't allowed to use the headers\n\n\n      if (!validCORSPreflightHeaders(xhr, resp, flag, properties)) {\n        setResponseToNetworkError(xhr);\n        return;\n      } // Set request gzip option right before headers are set\n\n\n      var realClient = doRequest();\n      realClient.on(\"response\", function () {\n        var _client3;\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return (_client3 = client).emit.apply(_client3, [\"response\"].concat(args));\n      });\n      realClient.on(\"data\", function (chunk) {\n        return client.emit(\"data\", chunk);\n      });\n      realClient.on(\"end\", function () {\n        return client.emit(\"end\");\n      });\n      realClient.on(\"abort\", function () {\n        return client.emit(\"abort\");\n      });\n      realClient.on(\"request\", function (req) {\n        client.headers = realClient.headers;\n        client.emit(\"request\", req);\n      });\n      realClient.on(\"redirect\", function () {\n        var _client4;\n\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        (_client4 = client).emit.apply(_client4, [\"redirect\"].concat(args));\n      });\n      realClient.on(\"error\", function (err) {\n        client.emit(\"error\", err);\n      });\n\n      client.abort = function () {\n        realClient.abort();\n      };\n\n      setImmediate(function () {\n        return realClient.end();\n      });\n    });\n    preflightClient.on(\"error\", function (err) {\n      client.emit(\"error\", err);\n    });\n\n    client.abort = function () {\n      preflightClient.abort();\n    };\n\n    setImmediate(function () {\n      return preflightClient.end();\n    });\n  } else {\n    client = doRequest();\n    setImmediate(function () {\n      return client.end();\n    });\n  }\n\n  if (requestManager) {\n    var _req = {\n      abort: function abort() {\n        properties.abortError = true;\n        xhr.abort();\n      }\n    };\n    requestManager.add(_req);\n\n    var _rmReq = requestManager.remove.bind(requestManager, _req);\n\n    client.on(\"abort\", _rmReq);\n    client.on(\"error\", _rmReq);\n    client.on(\"end\", _rmReq);\n  }\n\n  return client;\n}\n\nexports.headerListSeparatorRegexp = headerListSeparatorRegexp;\nexports.simpleHeaders = simpleHeaders;\nexports.preflightHeaders = preflightHeaders;\nexports.getRequestHeader = getRequestHeader;\nexports.updateRequestHeader = updateRequestHeader;\nexports.dispatchError = dispatchError;\nexports.validCORSHeaders = validCORSHeaders;\nexports.requestErrorSteps = requestErrorSteps;\nexports.setResponseToNetworkError = setResponseToNetworkError;\nexports.createClient = createClient;","map":null,"metadata":{},"sourceType":"script"}