{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/createClass\");\n\nvar fs = require(\"fs\");\n\nvar _require = require(\"url\"),\n    fileURLToPath = _require.fileURLToPath;\n\nvar _require2 = require(\"whatwg-url\"),\n    parseURL = _require2.parseURL;\n\nvar dataURLFromRecord = require(\"data-urls\").fromURLRecord;\n\nvar packageVersion = require(\"../../../../package.json\").version;\n\nvar agentFactory = require(\"../../living/helpers/agent-factory\");\n\nvar Request = require(\"../../living/helpers/http-request\");\n\nvar IS_BROWSER = Object.prototype.toString.call(process) !== \"[object process]\";\n\nmodule.exports = /*#__PURE__*/function () {\n  function ResourceLoader() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$strictSSL = _ref.strictSSL,\n        strictSSL = _ref$strictSSL === void 0 ? true : _ref$strictSSL,\n        _ref$proxy = _ref.proxy,\n        proxy = _ref$proxy === void 0 ? undefined : _ref$proxy,\n        _ref$userAgent = _ref.userAgent,\n        userAgent = _ref$userAgent === void 0 ? \"Mozilla/5.0 (\".concat(process.platform || \"unknown OS\", \") AppleWebKit/537.36 \") + \"(KHTML, like Gecko) jsdom/\".concat(packageVersion) : _ref$userAgent;\n\n    _classCallCheck(this, ResourceLoader);\n\n    this._strictSSL = strictSSL;\n    this._proxy = proxy;\n    this._userAgent = userAgent;\n  }\n\n  _createClass(ResourceLoader, [{\n    key: \"_readDataURL\",\n    value: function _readDataURL(urlRecord) {\n      var dataURL = dataURLFromRecord(urlRecord);\n      var timeoutId;\n      var promise = new Promise(function (resolve) {\n        timeoutId = setTimeout(resolve, 0, Buffer.from(dataURL.body));\n      });\n\n      promise.abort = function () {\n        if (timeoutId !== undefined) {\n          clearTimeout(timeoutId);\n        }\n      };\n\n      return promise;\n    }\n  }, {\n    key: \"_readFile\",\n    value: function _readFile(filePath) {\n      var readableStream, abort; // Native Promises doesn't have an \"abort\" method.\n      // Creating a promise for two reason:\n      //   1. fetch always return a promise.\n      //   2. We need to add an abort handler.\n\n      var promise = new Promise(function (resolve, reject) {\n        readableStream = fs.createReadStream(filePath);\n        var data = Buffer.alloc(0);\n        abort = reject;\n        readableStream.on(\"error\", reject);\n        readableStream.on(\"data\", function (chunk) {\n          data = Buffer.concat([data, chunk]);\n        });\n        readableStream.on(\"end\", function () {\n          resolve(data);\n        });\n      });\n\n      promise.abort = function () {\n        readableStream.destroy();\n        var error = new Error(\"request canceled by user\");\n        error.isAbortError = true;\n        abort(error);\n      };\n\n      return promise;\n    }\n  }, {\n    key: \"fetch\",\n    value: function fetch(urlString) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          accept = _ref2.accept,\n          cookieJar = _ref2.cookieJar,\n          referrer = _ref2.referrer;\n\n      var url = parseURL(urlString);\n\n      if (!url) {\n        return Promise.reject(new Error(\"Tried to fetch invalid URL \".concat(urlString)));\n      }\n\n      switch (url.scheme) {\n        case \"data\":\n          {\n            return this._readDataURL(url);\n          }\n\n        case \"http\":\n        case \"https\":\n          {\n            var agents = agentFactory(this._proxy, this._strictSSL);\n            var headers = {\n              \"User-Agent\": this._userAgent,\n              \"Accept-Language\": \"en\",\n              \"Accept-Encoding\": \"gzip\",\n              \"Accept\": accept || \"*/*\"\n            };\n\n            if (referrer && !IS_BROWSER) {\n              headers.Referer = referrer;\n            }\n\n            var requestClient = new Request(urlString, {\n              followRedirects: true,\n              cookieJar: cookieJar,\n              agents: agents\n            }, {\n              headers: headers\n            });\n            var promise = new Promise(function (resolve, reject) {\n              var accumulated = [];\n              requestClient.once(\"response\", function (res) {\n                promise.response = res;\n                var statusCode = res.statusCode; // TODO This deviates from the spec when it comes to\n                // loading resources such as images\n\n                if (statusCode < 200 || statusCode > 299) {\n                  requestClient.abort();\n                  reject(new Error(\"Resource was not loaded. Status: \".concat(statusCode)));\n                }\n              });\n              requestClient.on(\"data\", function (chunk) {\n                accumulated.push(chunk);\n              });\n              requestClient.on(\"end\", function () {\n                return resolve(Buffer.concat(accumulated));\n              });\n              requestClient.on(\"error\", reject);\n            }); // The method fromURL in lib/api.js crashes without the following four\n            // properties defined on the Promise instance, causing the test suite to halt\n\n            requestClient.on(\"end\", function () {\n              promise.href = requestClient.currentURL;\n            });\n            promise.abort = requestClient.abort.bind(requestClient);\n\n            promise.getHeader = function (name) {\n              return headers[name] || requestClient.getHeader(name);\n            };\n\n            requestClient.end();\n            return promise;\n          }\n\n        case \"file\":\n          {\n            try {\n              return this._readFile(fileURLToPath(urlString));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }\n\n        default:\n          {\n            return Promise.reject(new Error(\"Tried to fetch URL \".concat(urlString, \" with invalid scheme \").concat(url.scheme)));\n          }\n      }\n    }\n  }]);\n\n  return ResourceLoader;\n}();","map":null,"metadata":{},"sourceType":"script"}