{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _require = require(\"./encoding\"),\n    utf8Encode = _require.utf8Encode,\n    utf8DecodeWithoutBOM = _require.utf8DecodeWithoutBOM;\n\nvar _require2 = require(\"./percent-encoding\"),\n    percentDecodeBytes = _require2.percentDecodeBytes,\n    utf8PercentEncodeString = _require2.utf8PercentEncodeString,\n    isURLEncodedPercentEncode = _require2.isURLEncodedPercentEncode;\n\nfunction p(char) {\n  return char.codePointAt(0);\n} // https://url.spec.whatwg.org/#concept-urlencoded-parser\n\n\nfunction parseUrlencoded(input) {\n  var sequences = strictlySplitByteSequence(input, p(\"&\"));\n  var output = [];\n\n  var _iterator = _createForOfIteratorHelper(sequences),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var bytes = _step.value;\n\n      if (bytes.length === 0) {\n        continue;\n      }\n\n      var name = void 0,\n          value = void 0;\n      var indexOfEqual = bytes.indexOf(p(\"=\"));\n\n      if (indexOfEqual >= 0) {\n        name = bytes.slice(0, indexOfEqual);\n        value = bytes.slice(indexOfEqual + 1);\n      } else {\n        name = bytes;\n        value = new Uint8Array(0);\n      }\n\n      name = replaceByteInByteSequence(name, 0x2B, 0x20);\n      value = replaceByteInByteSequence(value, 0x2B, 0x20);\n      var nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));\n      var valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value));\n      output.push([nameString, valueString]);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return output;\n} // https://url.spec.whatwg.org/#concept-urlencoded-string-parser\n\n\nfunction parseUrlencodedString(input) {\n  return parseUrlencoded(utf8Encode(input));\n} // https://url.spec.whatwg.org/#concept-urlencoded-serializer\n\n\nfunction serializeUrlencoded(tuples) {\n  var encodingOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  var encoding = \"utf-8\";\n\n  if (encodingOverride !== undefined) {\n    // TODO \"get the output encoding\", i.e. handle encoding labels vs. names.\n    encoding = encodingOverride;\n  }\n\n  var output = \"\";\n\n  var _iterator2 = _createForOfIteratorHelper(tuples.entries()),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n          i = _step2$value[0],\n          tuple = _step2$value[1];\n\n      // TODO: handle encoding override\n      var name = utf8PercentEncodeString(tuple[0], isURLEncodedPercentEncode, true);\n      var value = tuple[1];\n\n      if (tuple.length > 2 && tuple[2] !== undefined) {\n        if (tuple[2] === \"hidden\" && name === \"_charset_\") {\n          value = encoding;\n        } else if (tuple[2] === \"file\") {\n          // value is a File object\n          value = value.name;\n        }\n      }\n\n      value = utf8PercentEncodeString(value, isURLEncodedPercentEncode, true);\n\n      if (i !== 0) {\n        output += \"&\";\n      }\n\n      output += \"\".concat(name, \"=\").concat(value);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return output;\n}\n\nfunction strictlySplitByteSequence(buf, cp) {\n  var list = [];\n  var last = 0;\n  var i = buf.indexOf(cp);\n\n  while (i >= 0) {\n    list.push(buf.slice(last, i));\n    last = i + 1;\n    i = buf.indexOf(cp, last);\n  }\n\n  if (last !== buf.length) {\n    list.push(buf.slice(last));\n  }\n\n  return list;\n}\n\nfunction replaceByteInByteSequence(buf, from, to) {\n  var i = buf.indexOf(from);\n\n  while (i >= 0) {\n    buf[i] = to;\n    i = buf.indexOf(from, i + 1);\n  }\n\n  return buf;\n}\n\nmodule.exports = {\n  parseUrlencodedString: parseUrlencodedString,\n  serializeUrlencoded: serializeUrlencoded\n};","map":null,"metadata":{},"sourceType":"script"}