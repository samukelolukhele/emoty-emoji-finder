{"ast":null,"code":"\"use strict\";\n\nfunction makeException(ErrorType, message) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (opts.globals) {\n    ErrorType = opts.globals[ErrorType.name];\n  }\n\n  return new ErrorType(\"\".concat(opts.context ? opts.context : \"Value\", \" \").concat(message, \".\"));\n}\n\nfunction toNumber(value) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!opts.globals) {\n    return +value;\n  }\n\n  if (typeof value === \"bigint\") {\n    throw opts.globals.TypeError(\"Cannot convert a BigInt value to a number\");\n  }\n\n  return opts.globals.Number(value);\n}\n\nfunction type(V) {\n  if (V === null) {\n    return \"Null\";\n  }\n\n  switch (typeof V) {\n    case \"undefined\":\n      return \"Undefined\";\n\n    case \"boolean\":\n      return \"Boolean\";\n\n    case \"number\":\n      return \"Number\";\n\n    case \"string\":\n      return \"String\";\n\n    case \"symbol\":\n      return \"Symbol\";\n\n    case \"bigint\":\n      return \"BigInt\";\n\n    case \"object\": // Falls through\n\n    case \"function\": // Falls through\n\n    default:\n      // Per ES spec, typeof returns an implemention-defined value that is not any of the existing ones for\n      // uncallable non-standard exotic objects. Yet Type() which the Web IDL spec depends on returns Object for\n      // such cases. So treat the default case as an object.\n      return \"Object\";\n  }\n} // Round x to the nearest integer, choosing the even integer if it lies halfway between two.\n\n\nfunction evenRound(x) {\n  // There are four cases for numbers with fractional part being .5:\n  //\n  // case |     x     | floor(x) | round(x) | expected | x <> 0 | x % 1 | x & 1 |   example\n  //   1  |  2n + 0.5 |  2n      |  2n + 1  |  2n      |   >    |  0.5  |   0   |  0.5 ->  0\n  //   2  |  2n + 1.5 |  2n + 1  |  2n + 2  |  2n + 2  |   >    |  0.5  |   1   |  1.5 ->  2\n  //   3  | -2n - 0.5 | -2n - 1  | -2n      | -2n      |   <    | -0.5  |   0   | -0.5 ->  0\n  //   4  | -2n - 1.5 | -2n - 2  | -2n - 1  | -2n - 2  |   <    | -0.5  |   1   | -1.5 -> -2\n  // (where n is a non-negative integer)\n  //\n  // Branch here for cases 1 and 4\n  if (x > 0 && x % 1 === +0.5 && (x & 1) === 0 || x < 0 && x % 1 === -0.5 && (x & 1) === 1) {\n    return censorNegativeZero(Math.floor(x));\n  }\n\n  return censorNegativeZero(Math.round(x));\n}\n\nfunction integerPart(n) {\n  return censorNegativeZero(Math.trunc(n));\n}\n\nfunction sign(x) {\n  return x < 0 ? -1 : 1;\n}\n\nfunction modulo(x, y) {\n  // https://tc39.github.io/ecma262/#eqn-modulo\n  // Note that http://stackoverflow.com/a/4467559/3191 does NOT work for large modulos\n  var signMightNotMatch = x % y;\n\n  if (sign(y) !== sign(signMightNotMatch)) {\n    return signMightNotMatch + y;\n  }\n\n  return signMightNotMatch;\n}\n\nfunction censorNegativeZero(x) {\n  return x === 0 ? 0 : x;\n}\n\nfunction createIntegerConversion(bitLength, typeOpts) {\n  var isSigned = !typeOpts.unsigned;\n  var lowerBound;\n  var upperBound;\n\n  if (bitLength === 64) {\n    upperBound = Number.MAX_SAFE_INTEGER;\n    lowerBound = !isSigned ? 0 : Number.MIN_SAFE_INTEGER;\n  } else if (!isSigned) {\n    lowerBound = 0;\n    upperBound = Math.pow(2, bitLength) - 1;\n  } else {\n    lowerBound = -Math.pow(2, bitLength - 1);\n    upperBound = Math.pow(2, bitLength - 1) - 1;\n  }\n\n  var twoToTheBitLength = Math.pow(2, bitLength);\n  var twoToOneLessThanTheBitLength = Math.pow(2, bitLength - 1);\n  return function (V) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var x = toNumber(V, opts);\n    x = censorNegativeZero(x);\n\n    if (opts.enforceRange) {\n      if (!Number.isFinite(x)) {\n        throw makeException(TypeError, \"is not a finite number\", opts);\n      }\n\n      x = integerPart(x);\n\n      if (x < lowerBound || x > upperBound) {\n        throw makeException(TypeError, \"is outside the accepted range of \".concat(lowerBound, \" to \").concat(upperBound, \", inclusive\"), opts);\n      }\n\n      return x;\n    }\n\n    if (!Number.isNaN(x) && opts.clamp) {\n      x = Math.min(Math.max(x, lowerBound), upperBound);\n      x = evenRound(x);\n      return x;\n    }\n\n    if (!Number.isFinite(x) || x === 0) {\n      return 0;\n    }\n\n    x = integerPart(x); // Math.pow(2, 64) is not accurately representable in JavaScript, so try to avoid these per-spec operations if\n    // possible. Hopefully it's an optimization for the non-64-bitLength cases too.\n\n    if (x >= lowerBound && x <= upperBound) {\n      return x;\n    } // These will not work great for bitLength of 64, but oh well. See the README for more details.\n\n\n    x = modulo(x, twoToTheBitLength);\n\n    if (isSigned && x >= twoToOneLessThanTheBitLength) {\n      return x - twoToTheBitLength;\n    }\n\n    return x;\n  };\n}\n\nfunction createLongLongConversion(bitLength, _ref) {\n  var unsigned = _ref.unsigned;\n  var upperBound = Number.MAX_SAFE_INTEGER;\n  var lowerBound = unsigned ? 0 : Number.MIN_SAFE_INTEGER;\n  var asBigIntN = unsigned ? BigInt.asUintN : BigInt.asIntN;\n  return function (V) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (opts === undefined) {\n      opts = {};\n    }\n\n    var x = toNumber(V, opts);\n    x = censorNegativeZero(x);\n\n    if (opts.enforceRange) {\n      if (!Number.isFinite(x)) {\n        throw makeException(TypeError, \"is not a finite number\", opts);\n      }\n\n      x = integerPart(x);\n\n      if (x < lowerBound || x > upperBound) {\n        throw makeException(TypeError, \"is outside the accepted range of \".concat(lowerBound, \" to \").concat(upperBound, \", inclusive\"), opts);\n      }\n\n      return x;\n    }\n\n    if (!Number.isNaN(x) && opts.clamp) {\n      x = Math.min(Math.max(x, lowerBound), upperBound);\n      x = evenRound(x);\n      return x;\n    }\n\n    if (!Number.isFinite(x) || x === 0) {\n      return 0;\n    }\n\n    var xBigInt = BigInt(integerPart(x));\n    xBigInt = asBigIntN(bitLength, xBigInt);\n    return Number(xBigInt);\n  };\n}\n\nexports.any = function (V) {\n  return V;\n};\n\nexports.void = function () {\n  return undefined;\n};\n\nexports.boolean = function (val) {\n  return !!val;\n};\n\nexports.byte = createIntegerConversion(8, {\n  unsigned: false\n});\nexports.octet = createIntegerConversion(8, {\n  unsigned: true\n});\nexports.short = createIntegerConversion(16, {\n  unsigned: false\n});\nexports[\"unsigned short\"] = createIntegerConversion(16, {\n  unsigned: true\n});\nexports.long = createIntegerConversion(32, {\n  unsigned: false\n});\nexports[\"unsigned long\"] = createIntegerConversion(32, {\n  unsigned: true\n});\nexports[\"long long\"] = createLongLongConversion(64, {\n  unsigned: false\n});\nexports[\"unsigned long long\"] = createLongLongConversion(64, {\n  unsigned: true\n});\n\nexports.double = function (V, opts) {\n  var x = toNumber(V, opts);\n\n  if (!Number.isFinite(x)) {\n    throw makeException(TypeError, \"is not a finite floating-point value\", opts);\n  }\n\n  return x;\n};\n\nexports[\"unrestricted double\"] = function (V, opts) {\n  var x = toNumber(V, opts);\n  return x;\n};\n\nexports.float = function (V, opts) {\n  var x = toNumber(V, opts);\n\n  if (!Number.isFinite(x)) {\n    throw makeException(TypeError, \"is not a finite floating-point value\", opts);\n  }\n\n  if (Object.is(x, -0)) {\n    return x;\n  }\n\n  var y = Math.fround(x);\n\n  if (!Number.isFinite(y)) {\n    throw makeException(TypeError, \"is outside the range of a single-precision floating-point value\", opts);\n  }\n\n  return y;\n};\n\nexports[\"unrestricted float\"] = function (V, opts) {\n  var x = toNumber(V, opts);\n\n  if (isNaN(x)) {\n    return x;\n  }\n\n  if (Object.is(x, -0)) {\n    return x;\n  }\n\n  return Math.fround(x);\n};\n\nexports.DOMString = function (V) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (opts.treatNullAsEmptyString && V === null) {\n    return \"\";\n  }\n\n  if (typeof V === \"symbol\") {\n    throw makeException(TypeError, \"is a symbol, which cannot be converted to a string\", opts);\n  }\n\n  var StringCtor = opts.globals ? opts.globals.String : String;\n  return StringCtor(V);\n};\n\nexports.ByteString = function (V, opts) {\n  var x = exports.DOMString(V, opts);\n  var c;\n\n  for (var i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {\n    if (c > 255) {\n      throw makeException(TypeError, \"is not a valid ByteString\", opts);\n    }\n  }\n\n  return x;\n};\n\nexports.USVString = function (V, opts) {\n  var S = exports.DOMString(V, opts);\n  var n = S.length;\n  var U = [];\n\n  for (var i = 0; i < n; ++i) {\n    var c = S.charCodeAt(i);\n\n    if (c < 0xD800 || c > 0xDFFF) {\n      U.push(String.fromCodePoint(c));\n    } else if (0xDC00 <= c && c <= 0xDFFF) {\n      U.push(String.fromCodePoint(0xFFFD));\n    } else if (i === n - 1) {\n      U.push(String.fromCodePoint(0xFFFD));\n    } else {\n      var d = S.charCodeAt(i + 1);\n\n      if (0xDC00 <= d && d <= 0xDFFF) {\n        var a = c & 0x3FF;\n        var b = d & 0x3FF;\n        U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));\n        ++i;\n      } else {\n        U.push(String.fromCodePoint(0xFFFD));\n      }\n    }\n  }\n\n  return U.join(\"\");\n};\n\nexports.object = function (V, opts) {\n  if (type(V) !== \"Object\") {\n    throw makeException(TypeError, \"is not an object\", opts);\n  }\n\n  return V;\n}; // Not exported, but used in Function and VoidFunction.\n// Neither Function nor VoidFunction is defined with [TreatNonObjectAsNull], so\n// handling for that is omitted.\n\n\nfunction convertCallbackFunction(V, opts) {\n  if (typeof V !== \"function\") {\n    throw makeException(TypeError, \"is not a function\", opts);\n  }\n\n  return V;\n}\n\nvar abByteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, \"byteLength\").get;\nvar sabByteLengthGetter = Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, \"byteLength\").get;\n\nfunction isNonSharedArrayBuffer(V) {\n  try {\n    // This will throw on SharedArrayBuffers, but not detached ArrayBuffers.\n    // (The spec says it should throw, but the spec conflicts with implementations: https://github.com/tc39/ecma262/issues/678)\n    abByteLengthGetter.call(V);\n    return true;\n  } catch (_unused) {\n    return false;\n  }\n}\n\nfunction isSharedArrayBuffer(V) {\n  try {\n    sabByteLengthGetter.call(V);\n    return true;\n  } catch (_unused2) {\n    return false;\n  }\n}\n\nfunction isArrayBufferDetached(V) {\n  try {\n    // eslint-disable-next-line no-new\n    new Uint8Array(V);\n    return false;\n  } catch (_unused3) {\n    return true;\n  }\n}\n\nexports.ArrayBuffer = function (V) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!isNonSharedArrayBuffer(V)) {\n    if (opts.allowShared && !isSharedArrayBuffer(V)) {\n      throw makeException(TypeError, \"is not an ArrayBuffer or SharedArrayBuffer\", opts);\n    }\n\n    throw makeException(TypeError, \"is not an ArrayBuffer\", opts);\n  }\n\n  if (isArrayBufferDetached(V)) {\n    throw makeException(TypeError, \"is a detached ArrayBuffer\", opts);\n  }\n\n  return V;\n};\n\nvar dvByteLengthGetter = Object.getOwnPropertyDescriptor(DataView.prototype, \"byteLength\").get;\n\nexports.DataView = function (V) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  try {\n    dvByteLengthGetter.call(V);\n  } catch (e) {\n    throw makeException(TypeError, \"is not a DataView\", opts);\n  }\n\n  if (!opts.allowShared && isSharedArrayBuffer(V.buffer)) {\n    throw makeException(TypeError, \"is backed by a SharedArrayBuffer, which is not allowed\", opts);\n  }\n\n  if (isArrayBufferDetached(V.buffer)) {\n    throw makeException(TypeError, \"is backed by a detached ArrayBuffer\", opts);\n  }\n\n  return V;\n}; // Returns the unforgeable `TypedArray` constructor name or `undefined`,\n// if the `this` value isn't a valid `TypedArray` object.\n//\n// https://tc39.es/ecma262/#sec-get-%typedarray%.prototype-@@tostringtag\n\n\nvar typedArrayNameGetter = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array).prototype, Symbol.toStringTag).get;\n[Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray, Float32Array, Float64Array].forEach(function (func) {\n  var name = func.name;\n  var article = /^[AEIOU]/.test(name) ? \"an\" : \"a\";\n\n  exports[name] = function (V) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!ArrayBuffer.isView(V) || typedArrayNameGetter.call(V) !== name) {\n      throw makeException(TypeError, \"is not \".concat(article, \" \").concat(name, \" object\"), opts);\n    }\n\n    if (!opts.allowShared && isSharedArrayBuffer(V.buffer)) {\n      throw makeException(TypeError, \"is a view on a SharedArrayBuffer, which is not allowed\", opts);\n    }\n\n    if (isArrayBufferDetached(V.buffer)) {\n      throw makeException(TypeError, \"is a view on a detached ArrayBuffer\", opts);\n    }\n\n    return V;\n  };\n}); // Common definitions\n\nexports.ArrayBufferView = function (V) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!ArrayBuffer.isView(V)) {\n    throw makeException(TypeError, \"is not a view on an ArrayBuffer or SharedArrayBuffer\", opts);\n  }\n\n  if (!opts.allowShared && isSharedArrayBuffer(V.buffer)) {\n    throw makeException(TypeError, \"is a view on a SharedArrayBuffer, which is not allowed\", opts);\n  }\n\n  if (isArrayBufferDetached(V.buffer)) {\n    throw makeException(TypeError, \"is a view on a detached ArrayBuffer\", opts);\n  }\n\n  return V;\n};\n\nexports.BufferSource = function (V) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (ArrayBuffer.isView(V)) {\n    if (!opts.allowShared && isSharedArrayBuffer(V.buffer)) {\n      throw makeException(TypeError, \"is a view on a SharedArrayBuffer, which is not allowed\", opts);\n    }\n\n    if (isArrayBufferDetached(V.buffer)) {\n      throw makeException(TypeError, \"is a view on a detached ArrayBuffer\", opts);\n    }\n\n    return V;\n  }\n\n  if (!opts.allowShared && !isNonSharedArrayBuffer(V)) {\n    throw makeException(TypeError, \"is not an ArrayBuffer or a view on one\", opts);\n  }\n\n  if (opts.allowShared && !isSharedArrayBuffer(V) && !isNonSharedArrayBuffer(V)) {\n    throw makeException(TypeError, \"is not an ArrayBuffer, SharedArrayBufer, or a view on one\", opts);\n  }\n\n  if (isArrayBufferDetached(V)) {\n    throw makeException(TypeError, \"is a detached ArrayBuffer\", opts);\n  }\n\n  return V;\n};\n\nexports.DOMTimeStamp = exports[\"unsigned long long\"];\nexports.Function = convertCallbackFunction;\nexports.VoidFunction = convertCallbackFunction;","map":null,"metadata":{},"sourceType":"script"}