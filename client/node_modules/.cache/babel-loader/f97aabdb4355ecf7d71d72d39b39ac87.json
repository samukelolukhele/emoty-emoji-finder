{"ast":null,"code":"\"use strict\"; // https://infra.spec.whatwg.org/#ascii-whitespace\n\nvar asciiWhitespaceRe = /^[\\t\\n\\f\\r ]$/;\nexports.asciiWhitespaceRe = asciiWhitespaceRe; // https://infra.spec.whatwg.org/#ascii-lowercase\n\nexports.asciiLowercase = function (s) {\n  return s.replace(/[A-Z]/g, function (l) {\n    return l.toLowerCase();\n  });\n}; // https://infra.spec.whatwg.org/#ascii-uppercase\n\n\nexports.asciiUppercase = function (s) {\n  return s.replace(/[a-z]/g, function (l) {\n    return l.toUpperCase();\n  });\n}; // https://infra.spec.whatwg.org/#strip-newlines\n\n\nexports.stripNewlines = function (s) {\n  return s.replace(/[\\n\\r]+/g, \"\");\n}; // https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\n\n\nexports.stripLeadingAndTrailingASCIIWhitespace = function (s) {\n  return s.replace(/^[ \\t\\n\\f\\r]+/, \"\").replace(/[ \\t\\n\\f\\r]+$/, \"\");\n}; // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\n\nexports.stripAndCollapseASCIIWhitespace = function (s) {\n  return s.replace(/[ \\t\\n\\f\\r]+/g, \" \").replace(/^[ \\t\\n\\f\\r]+/, \"\").replace(/[ \\t\\n\\f\\r]+$/, \"\");\n}; // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-simple-colour\n\n\nexports.isValidSimpleColor = function (s) {\n  return /^#[a-fA-F\\d]{6}$/.test(s);\n}; // https://infra.spec.whatwg.org/#ascii-case-insensitive\n\n\nexports.asciiCaseInsensitiveMatch = function (a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (var i = 0; i < a.length; ++i) {\n    if ((a.charCodeAt(i) | 32) !== (b.charCodeAt(i) | 32)) {\n      return false;\n    }\n  }\n\n  return true;\n}; // https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#rules-for-parsing-integers\n// Error is represented as null.\n\n\nvar parseInteger = exports.parseInteger = function (input) {\n  // The implementation here is slightly different from the spec's. We want to use parseInt(), but parseInt() trims\n  // Unicode whitespace in addition to just ASCII ones, so we make sure that the trimmed prefix contains only ASCII\n  // whitespace ourselves.\n  var numWhitespace = input.length - input.trimStart().length;\n\n  if (/[^\\t\\n\\f\\r ]/.test(input.slice(0, numWhitespace))) {\n    return null;\n  } // We don't allow hexadecimal numbers here.\n  // eslint-disable-next-line radix\n\n\n  var value = parseInt(input, 10);\n\n  if (Number.isNaN(value)) {\n    return null;\n  } // parseInt() returns -0 for \"-0\". Normalize that here.\n\n\n  return value === 0 ? 0 : value;\n}; // https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#rules-for-parsing-non-negative-integers\n// Error is represented as null.\n\n\nexports.parseNonNegativeInteger = function (input) {\n  var value = parseInteger(input);\n\n  if (value === null) {\n    return null;\n  }\n\n  if (value < 0) {\n    return null;\n  }\n\n  return value;\n}; // https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#valid-floating-point-number\n\n\nvar floatingPointNumRe = /^-?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?$/;\n\nexports.isValidFloatingPointNumber = function (str) {\n  return floatingPointNumRe.test(str);\n}; // https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#rules-for-parsing-floating-point-number-values\n// Error is represented as null.\n\n\nexports.parseFloatingPointNumber = function (str) {\n  // The implementation here is slightly different from the spec's. We need to use parseFloat() in order to retain\n  // accuracy, but parseFloat() trims Unicode whitespace in addition to just ASCII ones, so we make sure that the\n  // trimmed prefix contains only ASCII whitespace ourselves.\n  var numWhitespace = str.length - str.trimStart().length;\n\n  if (/[^\\t\\n\\f\\r ]/.test(str.slice(0, numWhitespace))) {\n    return null;\n  }\n\n  var parsed = parseFloat(str);\n  return isFinite(parsed) ? parsed : null;\n}; // https://infra.spec.whatwg.org/#split-on-ascii-whitespace\n\n\nexports.splitOnASCIIWhitespace = function (str) {\n  var position = 0;\n  var tokens = [];\n\n  while (position < str.length && asciiWhitespaceRe.test(str[position])) {\n    position++;\n  }\n\n  if (position === str.length) {\n    return tokens;\n  }\n\n  while (position < str.length) {\n    var start = position;\n\n    while (position < str.length && !asciiWhitespaceRe.test(str[position])) {\n      position++;\n    }\n\n    tokens.push(str.slice(start, position));\n\n    while (position < str.length && asciiWhitespaceRe.test(str[position])) {\n      position++;\n    }\n  }\n\n  return tokens;\n}; // https://infra.spec.whatwg.org/#split-on-commas\n\n\nexports.splitOnCommas = function (str) {\n  var position = 0;\n  var tokens = [];\n\n  while (position < str.length) {\n    var start = position;\n\n    while (position < str.length && str[position] !== \",\") {\n      position++;\n    }\n\n    var end = position;\n\n    while (start < str.length && asciiWhitespaceRe.test(str[start])) {\n      start++;\n    }\n\n    while (end > start && asciiWhitespaceRe.test(str[end - 1])) {\n      end--;\n    }\n\n    tokens.push(str.slice(start, end));\n\n    if (position < str.length) {\n      position++;\n    }\n  }\n\n  return tokens;\n};","map":null,"metadata":{},"sourceType":"script"}