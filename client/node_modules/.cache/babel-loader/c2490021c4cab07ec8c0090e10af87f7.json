{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _defineProperty = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _objectSpread = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _createForOfIteratorHelper = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _slicedToArray = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar vm = require(\"vm\");\n\nvar webIDLConversions = require(\"webidl-conversions\");\n\nvar _require = require(\"cssstyle\"),\n    CSSStyleDeclaration = _require.CSSStyleDeclaration;\n\nvar _require2 = require(\"w3c-hr-time\"),\n    RawPerformance = _require2.Performance;\n\nvar notImplemented = require(\"./not-implemented\");\n\nvar _require3 = require(\"../living/interfaces\"),\n    installInterfaces = _require3.installInterfaces;\n\nvar _require4 = require(\"../utils\"),\n    define = _require4.define,\n    mixin = _require4.mixin;\n\nvar Element = require(\"../living/generated/Element\");\n\nvar EventTarget = require(\"../living/generated/EventTarget\");\n\nvar EventHandlerNonNull = require(\"../living/generated/EventHandlerNonNull\");\n\nvar OnBeforeUnloadEventHandlerNonNull = require(\"../living/generated/OnBeforeUnloadEventHandlerNonNull\");\n\nvar OnErrorEventHandlerNonNull = require(\"../living/generated/OnErrorEventHandlerNonNull\");\n\nvar PageTransitionEvent = require(\"../living/generated/PageTransitionEvent\");\n\nvar namedPropertiesWindow = require(\"../living/named-properties-window\");\n\nvar postMessage = require(\"../living/post-message\");\n\nvar DOMException = require(\"domexception/webidl2js-wrapper\");\n\nvar _require5 = require(\"abab\"),\n    btoa = _require5.btoa,\n    atob = _require5.atob;\n\nvar idlUtils = require(\"../living/generated/utils\");\n\nvar WebSocketImpl = require(\"../living/websockets/WebSocket-impl\").implementation;\n\nvar BarProp = require(\"../living/generated/BarProp\");\n\nvar documents = require(\"../living/documents.js\");\n\nvar External = require(\"../living/generated/External\");\n\nvar Navigator = require(\"../living/generated/Navigator\");\n\nvar Performance = require(\"../living/generated/Performance\");\n\nvar Screen = require(\"../living/generated/Screen\");\n\nvar Storage = require(\"../living/generated/Storage\");\n\nvar Selection = require(\"../living/generated/Selection\");\n\nvar reportException = require(\"../living/helpers/runtime-script-errors\");\n\nvar _require6 = require(\"../living/helpers/create-event-accessor.js\"),\n    getCurrentEventHandlerValue = _require6.getCurrentEventHandlerValue;\n\nvar _require7 = require(\"../living/helpers/events\"),\n    fireAnEvent = _require7.fireAnEvent;\n\nvar SessionHistory = require(\"../living/window/SessionHistory\");\n\nvar _require8 = require(\"../living/helpers/style-rules.js\"),\n    forEachMatchingSheetRuleOfElement = _require8.forEachMatchingSheetRuleOfElement,\n    getResolvedValue = _require8.getResolvedValue,\n    propertiesWithResolvedValueImplemented = _require8.propertiesWithResolvedValueImplemented,\n    SHADOW_DOM_PSEUDO_REGEXP = _require8.SHADOW_DOM_PSEUDO_REGEXP;\n\nvar CustomElementRegistry = require(\"../living/generated/CustomElementRegistry\");\n\nvar jsGlobals = require(\"./js-globals.json\");\n\nvar GlobalEventHandlersImpl = require(\"../living/nodes/GlobalEventHandlers-impl\").implementation;\n\nvar WindowEventHandlersImpl = require(\"../living/nodes/WindowEventHandlers-impl\").implementation;\n\nvar events = new Set([// GlobalEventHandlers\n\"abort\", \"autocomplete\", \"autocompleteerror\", \"blur\", \"cancel\", \"canplay\", \"canplaythrough\", \"change\", \"click\", \"close\", \"contextmenu\", \"cuechange\", \"dblclick\", \"drag\", \"dragend\", \"dragenter\", \"dragleave\", \"dragover\", \"dragstart\", \"drop\", \"durationchange\", \"emptied\", \"ended\", \"focus\", \"input\", \"invalid\", \"keydown\", \"keypress\", \"keyup\", \"load\", \"loadeddata\", \"loadedmetadata\", \"loadstart\", \"mousedown\", \"mouseenter\", \"mouseleave\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"wheel\", \"pause\", \"play\", \"playing\", \"progress\", \"ratechange\", \"reset\", \"resize\", \"scroll\", \"securitypolicyviolation\", \"seeked\", \"seeking\", \"select\", \"sort\", \"stalled\", \"submit\", \"suspend\", \"timeupdate\", \"toggle\", \"volumechange\", \"waiting\", // WindowEventHandlers\n\"afterprint\", \"beforeprint\", \"hashchange\", \"languagechange\", \"message\", \"messageerror\", \"offline\", \"online\", \"pagehide\", \"pageshow\", \"popstate\", \"rejectionhandled\", \"storage\", \"unhandledrejection\", \"unload\" // \"error\" and \"beforeunload\" are added separately\n]);\n\nexports.createWindow = function (options) {\n  return new Window(options);\n};\n\nvar jsGlobalEntriesToInstall = Object.entries(jsGlobals).filter(function (_ref) {\n  var _ref2 = _slicedToArray(_ref, 1),\n      name = _ref2[0];\n\n  return name in global;\n}); // https://html.spec.whatwg.org/#the-window-object\n\nfunction setupWindow(windowInstance, _ref3) {\n  var runScripts = _ref3.runScripts;\n\n  if (runScripts === \"outside-only\" || runScripts === \"dangerously\") {\n    contextifyWindow(windowInstance); // Without this, these globals will only appear to scripts running inside the context using vm.runScript; they will\n    // not appear to scripts running from the outside, including to JSDOM implementation code.\n\n    var _iterator = _createForOfIteratorHelper(jsGlobalEntriesToInstall),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n            globalName = _step$value[0],\n            globalPropDesc = _step$value[1];\n\n        var propDesc = _objectSpread(_objectSpread({}, globalPropDesc), {}, {\n          value: vm.runInContext(globalName, windowInstance)\n        });\n\n        Object.defineProperty(windowInstance, globalName, propDesc);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else {\n    // Without contextifying the window, none of the globals will exist. So, let's at least alias them from the Node.js\n    // context. See https://github.com/jsdom/jsdom/issues/2727 for more background and discussion.\n    var _iterator2 = _createForOfIteratorHelper(jsGlobalEntriesToInstall),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n            _globalName = _step2$value[0],\n            _globalPropDesc = _step2$value[1];\n\n        var _propDesc = _objectSpread(_objectSpread({}, _globalPropDesc), {}, {\n          value: global[_globalName]\n        });\n\n        Object.defineProperty(windowInstance, _globalName, _propDesc);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  installInterfaces(windowInstance, [\"Window\"]);\n  var EventTargetConstructor = windowInstance.EventTarget; // eslint-disable-next-line func-name-matching, func-style, no-shadow\n\n  var windowConstructor = function Window() {\n    throw new TypeError(\"Illegal constructor\");\n  };\n\n  Object.setPrototypeOf(windowConstructor, EventTargetConstructor);\n  Object.defineProperty(windowInstance, \"Window\", {\n    configurable: true,\n    writable: true,\n    value: windowConstructor\n  });\n  var windowPrototype = Object.create(EventTargetConstructor.prototype);\n  Object.defineProperties(windowPrototype, _defineProperty({\n    constructor: {\n      value: windowConstructor,\n      writable: true,\n      configurable: true\n    }\n  }, Symbol.toStringTag, {\n    value: \"Window\",\n    configurable: true\n  }));\n  windowConstructor.prototype = windowPrototype;\n  Object.setPrototypeOf(windowInstance, windowPrototype);\n  EventTarget.setup(windowInstance, windowInstance);\n  mixin(windowInstance, WindowEventHandlersImpl.prototype);\n  mixin(windowInstance, GlobalEventHandlersImpl.prototype);\n\n  windowInstance._initGlobalEvents();\n\n  Object.defineProperty(windowInstance, \"onbeforeunload\", {\n    configurable: true,\n    enumerable: true,\n    get: function get() {\n      return idlUtils.tryWrapperForImpl(getCurrentEventHandlerValue(this, \"beforeunload\"));\n    },\n    set: function set(V) {\n      if (!idlUtils.isObject(V)) {\n        V = null;\n      } else {\n        V = OnBeforeUnloadEventHandlerNonNull.convert(V, {\n          context: \"Failed to set the 'onbeforeunload' property on 'Window': The provided value\"\n        });\n      }\n\n      this._setEventHandlerFor(\"beforeunload\", V);\n    }\n  });\n  Object.defineProperty(windowInstance, \"onerror\", {\n    configurable: true,\n    enumerable: true,\n    get: function get() {\n      return idlUtils.tryWrapperForImpl(getCurrentEventHandlerValue(this, \"error\"));\n    },\n    set: function set(V) {\n      if (!idlUtils.isObject(V)) {\n        V = null;\n      } else {\n        V = OnErrorEventHandlerNonNull.convert(V, {\n          context: \"Failed to set the 'onerror' property on 'Window': The provided value\"\n        });\n      }\n\n      this._setEventHandlerFor(\"error\", V);\n    }\n  });\n\n  var _iterator3 = _createForOfIteratorHelper(events),\n      _step3;\n\n  try {\n    var _loop = function _loop() {\n      var event = _step3.value;\n      Object.defineProperty(windowInstance, \"on\".concat(event), {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n          return idlUtils.tryWrapperForImpl(getCurrentEventHandlerValue(this, event));\n        },\n        set: function set(V) {\n          if (!idlUtils.isObject(V)) {\n            V = null;\n          } else {\n            V = EventHandlerNonNull.convert(V, {\n              context: \"Failed to set the 'on\".concat(event, \"' property on 'Window': The provided value\")\n            });\n          }\n\n          this._setEventHandlerFor(event, V);\n        }\n      });\n    };\n\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  windowInstance._globalObject = windowInstance;\n} // NOTE: per https://heycam.github.io/webidl/#Global, all properties on the Window object must be own-properties.\n// That is why we assign everything inside of the constructor, instead of using a shared prototype.\n// You can verify this in e.g. Firefox or Internet Explorer, which do a good job with Web IDL compliance.\n\n\nfunction Window(options) {\n  var _this = this;\n\n  setupWindow(this, {\n    runScripts: options.runScripts\n  });\n  var rawPerformance = new RawPerformance();\n  var windowInitialized = rawPerformance.now();\n  var window = this; // ### PRIVATE DATA PROPERTIES\n\n  this._resourceLoader = options.resourceLoader; // vm initialization is deferred until script processing is activated\n\n  this._globalProxy = this;\n  Object.defineProperty(idlUtils.implForWrapper(this), idlUtils.wrapperSymbol, {\n    get: function get() {\n      return _this._globalProxy;\n    }\n  }); // List options explicitly to be clear which are passed through\n\n  this._document = documents.createWrapper(window, {\n    parsingMode: options.parsingMode,\n    contentType: options.contentType,\n    encoding: options.encoding,\n    cookieJar: options.cookieJar,\n    url: options.url,\n    lastModified: options.lastModified,\n    referrer: options.referrer,\n    parseOptions: options.parseOptions,\n    defaultView: this._globalProxy,\n    global: this,\n    parentOrigin: options.parentOrigin\n  }, {\n    alwaysUseDocumentClass: true\n  });\n\n  if (vm.isContext(window)) {\n    var documentImpl = idlUtils.implForWrapper(window._document);\n    documentImpl._defaultView = window._globalProxy = vm.runInContext(\"this\", window);\n  }\n\n  var documentOrigin = idlUtils.implForWrapper(this._document)._origin;\n\n  this._origin = documentOrigin; // https://html.spec.whatwg.org/#session-history\n\n  this._sessionHistory = new SessionHistory({\n    document: idlUtils.implForWrapper(this._document),\n    url: idlUtils.implForWrapper(this._document)._URL,\n    stateObject: null\n  }, this);\n  this._virtualConsole = options.virtualConsole;\n  this._runScripts = options.runScripts; // Set up the window as if it's a top level window.\n  // If it's not, then references will be corrected by frame/iframe code.\n\n  this._parent = this._top = this._globalProxy;\n  this._frameElement = null; // This implements window.frames.length, since window.frames returns a\n  // self reference to the window object.  This value is incremented in the\n  // HTMLFrameElement implementation.\n\n  this._length = 0; // https://dom.spec.whatwg.org/#window-current-event\n\n  this._currentEvent = undefined;\n  this._pretendToBeVisual = options.pretendToBeVisual;\n  this._storageQuota = options.storageQuota; // Some properties (such as localStorage and sessionStorage) share data\n  // between windows in the same origin. This object is intended\n  // to contain such data.\n\n  if (options.commonForOrigin && options.commonForOrigin[documentOrigin]) {\n    this._commonForOrigin = options.commonForOrigin;\n  } else {\n    this._commonForOrigin = _defineProperty({}, documentOrigin, {\n      localStorageArea: new Map(),\n      sessionStorageArea: new Map(),\n      windowsInSameOrigin: [this]\n    });\n  }\n\n  this._currentOriginData = this._commonForOrigin[documentOrigin]; // ### WEB STORAGE\n\n  this._localStorage = Storage.create(window, [], {\n    associatedWindow: this,\n    storageArea: this._currentOriginData.localStorageArea,\n    type: \"localStorage\",\n    url: this._document.documentURI,\n    storageQuota: this._storageQuota\n  });\n  this._sessionStorage = Storage.create(window, [], {\n    associatedWindow: this,\n    storageArea: this._currentOriginData.sessionStorageArea,\n    type: \"sessionStorage\",\n    url: this._document.documentURI,\n    storageQuota: this._storageQuota\n  }); // ### SELECTION\n  // https://w3c.github.io/selection-api/#dfn-selection\n\n  this._selection = Selection.createImpl(window); // https://w3c.github.io/selection-api/#dom-window\n\n  this.getSelection = function () {\n    return window._selection;\n  }; // ### GETTERS\n\n\n  var locationbar = BarProp.create(window);\n  var menubar = BarProp.create(window);\n  var personalbar = BarProp.create(window);\n  var scrollbars = BarProp.create(window);\n  var statusbar = BarProp.create(window);\n  var toolbar = BarProp.create(window);\n  var external = External.create(window);\n  var navigator = Navigator.create(window, [], {\n    userAgent: this._resourceLoader._userAgent\n  });\n  var performance = Performance.create(window, [], {\n    rawPerformance: rawPerformance\n  });\n  var screen = Screen.create(window);\n  var customElementRegistry = CustomElementRegistry.create(window);\n  define(this, {\n    get length() {\n      return window._length;\n    },\n\n    get window() {\n      return window._globalProxy;\n    },\n\n    get frameElement() {\n      return idlUtils.wrapperForImpl(window._frameElement);\n    },\n\n    get frames() {\n      return window._globalProxy;\n    },\n\n    get self() {\n      return window._globalProxy;\n    },\n\n    get parent() {\n      return window._parent;\n    },\n\n    get top() {\n      return window._top;\n    },\n\n    get document() {\n      return window._document;\n    },\n\n    get external() {\n      return external;\n    },\n\n    get location() {\n      return idlUtils.wrapperForImpl(idlUtils.implForWrapper(window._document)._location);\n    },\n\n    get history() {\n      return idlUtils.wrapperForImpl(idlUtils.implForWrapper(window._document)._history);\n    },\n\n    get navigator() {\n      return navigator;\n    },\n\n    get locationbar() {\n      return locationbar;\n    },\n\n    get menubar() {\n      return menubar;\n    },\n\n    get personalbar() {\n      return personalbar;\n    },\n\n    get scrollbars() {\n      return scrollbars;\n    },\n\n    get statusbar() {\n      return statusbar;\n    },\n\n    get toolbar() {\n      return toolbar;\n    },\n\n    get performance() {\n      return performance;\n    },\n\n    get screen() {\n      return screen;\n    },\n\n    get origin() {\n      return window._origin;\n    },\n\n    // The origin IDL attribute is defined with [Replaceable].\n    set origin(value) {\n      Object.defineProperty(this, \"origin\", {\n        value: value,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n    },\n\n    get localStorage() {\n      if (idlUtils.implForWrapper(this._document)._origin === \"null\") {\n        throw DOMException.create(window, [\"localStorage is not available for opaque origins\", \"SecurityError\"]);\n      }\n\n      return this._localStorage;\n    },\n\n    get sessionStorage() {\n      if (idlUtils.implForWrapper(this._document)._origin === \"null\") {\n        throw DOMException.create(window, [\"sessionStorage is not available for opaque origins\", \"SecurityError\"]);\n      }\n\n      return this._sessionStorage;\n    },\n\n    get customElements() {\n      return customElementRegistry;\n    },\n\n    get event() {\n      return window._currentEvent ? idlUtils.wrapperForImpl(window._currentEvent) : undefined;\n    },\n\n    set event(value) {\n      Object.defineProperty(window, \"event\", {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: value\n      });\n    }\n\n  });\n  namedPropertiesWindow.initializeWindow(this, this._globalProxy); // ### METHODS\n  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers\n  // In the spec the list of active timers is a set of IDs. We make it a map of IDs to Node.js timer objects, so that\n  // we can call Node.js-side clearTimeout() when clearing, and thus allow process shutdown faster.\n\n  var listOfActiveTimers = new Map();\n  var latestTimerId = 0;\n\n  this.setTimeout = function (handler) {\n    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    if (typeof handler !== \"function\") {\n      handler = webIDLConversions.DOMString(handler);\n    }\n\n    timeout = webIDLConversions.long(timeout);\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return timerInitializationSteps(handler, timeout, args, {\n      methodContext: window,\n      repeat: false\n    });\n  };\n\n  this.setInterval = function (handler) {\n    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    if (typeof handler !== \"function\") {\n      handler = webIDLConversions.DOMString(handler);\n    }\n\n    timeout = webIDLConversions.long(timeout);\n\n    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      args[_key2 - 2] = arguments[_key2];\n    }\n\n    return timerInitializationSteps(handler, timeout, args, {\n      methodContext: window,\n      repeat: true\n    });\n  };\n\n  this.clearTimeout = function () {\n    var handle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    handle = webIDLConversions.long(handle);\n    var nodejsTimer = listOfActiveTimers.get(handle);\n\n    if (nodejsTimer) {\n      clearTimeout(nodejsTimer);\n      listOfActiveTimers.delete(handle);\n    }\n  };\n\n  this.clearInterval = function () {\n    var handle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    handle = webIDLConversions.long(handle);\n    var nodejsTimer = listOfActiveTimers.get(handle);\n\n    if (nodejsTimer) {\n      // We use setTimeout() in timerInitializationSteps even for this.setInterval().\n      clearTimeout(nodejsTimer);\n      listOfActiveTimers.delete(handle);\n    }\n  };\n\n  function timerInitializationSteps(handler, timeout, args, _ref4) {\n    var methodContext = _ref4.methodContext,\n        repeat = _ref4.repeat,\n        previousHandle = _ref4.previousHandle;\n\n    // This appears to be unspecced, but matches browser behavior for close()ed windows.\n    if (!methodContext._document) {\n      return 0;\n    } // TODO: implement timer nesting level behavior.\n\n\n    var methodContextProxy = methodContext._globalProxy;\n    var handle = previousHandle !== undefined ? previousHandle : ++latestTimerId;\n\n    function task() {\n      if (!listOfActiveTimers.has(handle)) {\n        return;\n      }\n\n      try {\n        if (typeof handler === \"function\") {\n          handler.apply(methodContextProxy, args);\n        } else if (window._runScripts === \"dangerously\") {\n          vm.runInContext(handler, window, {\n            filename: window.location.href,\n            displayErrors: false\n          });\n        }\n      } catch (e) {\n        reportException(window, e, window.location.href);\n      }\n\n      if (listOfActiveTimers.has(handle)) {\n        if (repeat) {\n          timerInitializationSteps(handler, timeout, args, {\n            methodContext: methodContext,\n            repeat: true,\n            previousHandle: handle\n          });\n        } else {\n          listOfActiveTimers.delete(handle);\n        }\n      }\n    }\n\n    if (timeout < 0) {\n      timeout = 0;\n    }\n\n    var nodejsTimer = setTimeout(task, timeout);\n    listOfActiveTimers.set(handle, nodejsTimer);\n    return handle;\n  } // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#microtask-queuing\n\n\n  this.queueMicrotask = function (callback) {\n    callback = webIDLConversions.Function(callback);\n    queueMicrotask(function () {\n      try {\n        callback();\n      } catch (e) {\n        reportException(window, e, window.location.href);\n      }\n    });\n  }; // https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#animation-frames\n\n\n  var animationFrameCallbackId = 0;\n  var mapOfAnimationFrameCallbacks = new Map();\n  var animationFrameNodejsInterval = null; // Unlike the spec, where an animation frame happens every 60 Hz regardless, we optimize so that if there are no\n  // requestAnimationFrame() calls outstanding, we don't fire the timer. This helps us track that.\n\n  var numberOfOngoingAnimationFrameCallbacks = 0;\n\n  if (this._pretendToBeVisual) {\n    var runAnimationFrameCallbacks = function runAnimationFrameCallbacks(now) {\n      // Converting to an array is important to get a sync snapshot and thus match spec semantics.\n      var callbackHandles = _toConsumableArray(mapOfAnimationFrameCallbacks.keys());\n\n      var _iterator4 = _createForOfIteratorHelper(callbackHandles),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var handle = _step4.value;\n\n          // This has() can be false if a callback calls cancelAnimationFrame().\n          if (mapOfAnimationFrameCallbacks.has(handle)) {\n            var callback = mapOfAnimationFrameCallbacks.get(handle);\n            removeAnimationFrameCallback(handle);\n\n            try {\n              callback(now);\n            } catch (e) {\n              reportException(window, e, window.location.href);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    };\n\n    var removeAnimationFrameCallback = function removeAnimationFrameCallback(handle) {\n      if (mapOfAnimationFrameCallbacks.has(handle)) {\n        --numberOfOngoingAnimationFrameCallbacks;\n\n        if (numberOfOngoingAnimationFrameCallbacks === 0) {\n          clearInterval(animationFrameNodejsInterval);\n        }\n      }\n\n      mapOfAnimationFrameCallbacks.delete(handle);\n    };\n\n    this.requestAnimationFrame = function (callback) {\n      callback = webIDLConversions.Function(callback);\n      var handle = ++animationFrameCallbackId;\n      mapOfAnimationFrameCallbacks.set(handle, callback);\n      ++numberOfOngoingAnimationFrameCallbacks;\n\n      if (numberOfOngoingAnimationFrameCallbacks === 1) {\n        animationFrameNodejsInterval = setInterval(function () {\n          runAnimationFrameCallbacks(rawPerformance.now() - windowInitialized);\n        }, 1000 / 60);\n      }\n\n      return handle;\n    };\n\n    this.cancelAnimationFrame = function (handle) {\n      handle = webIDLConversions[\"unsigned long\"](handle);\n      removeAnimationFrameCallback(handle);\n    };\n  }\n\n  function stopAllTimers() {\n    var _iterator5 = _createForOfIteratorHelper(listOfActiveTimers.values()),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var nodejsTimer = _step5.value;\n        clearTimeout(nodejsTimer);\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n\n    listOfActiveTimers.clear();\n    clearInterval(animationFrameNodejsInterval);\n  }\n\n  function Option(text, value, defaultSelected, selected) {\n    if (text === undefined) {\n      text = \"\";\n    }\n\n    text = webIDLConversions.DOMString(text);\n\n    if (value !== undefined) {\n      value = webIDLConversions.DOMString(value);\n    }\n\n    defaultSelected = webIDLConversions.boolean(defaultSelected);\n    selected = webIDLConversions.boolean(selected);\n\n    var option = window._document.createElement(\"option\");\n\n    var impl = idlUtils.implForWrapper(option);\n\n    if (text !== \"\") {\n      impl.text = text;\n    }\n\n    if (value !== undefined) {\n      impl.setAttributeNS(null, \"value\", value);\n    }\n\n    if (defaultSelected) {\n      impl.setAttributeNS(null, \"selected\", \"\");\n    }\n\n    impl._selectedness = selected;\n    return option;\n  }\n\n  Object.defineProperty(Option, \"prototype\", {\n    value: this.HTMLOptionElement.prototype,\n    configurable: false,\n    enumerable: false,\n    writable: false\n  });\n  Object.defineProperty(window, \"Option\", {\n    value: Option,\n    configurable: true,\n    enumerable: false,\n    writable: true\n  });\n\n  function Image() {\n    var img = window._document.createElement(\"img\");\n\n    var impl = idlUtils.implForWrapper(img);\n\n    if (arguments.length > 0) {\n      impl.setAttributeNS(null, \"width\", String(arguments.length <= 0 ? undefined : arguments[0]));\n    }\n\n    if (arguments.length > 1) {\n      impl.setAttributeNS(null, \"height\", String(arguments.length <= 1 ? undefined : arguments[1]));\n    }\n\n    return img;\n  }\n\n  Object.defineProperty(Image, \"prototype\", {\n    value: this.HTMLImageElement.prototype,\n    configurable: false,\n    enumerable: false,\n    writable: false\n  });\n  Object.defineProperty(window, \"Image\", {\n    value: Image,\n    configurable: true,\n    enumerable: false,\n    writable: true\n  });\n\n  function Audio(src) {\n    var audio = window._document.createElement(\"audio\");\n\n    var impl = idlUtils.implForWrapper(audio);\n    impl.setAttributeNS(null, \"preload\", \"auto\");\n\n    if (src !== undefined) {\n      impl.setAttributeNS(null, \"src\", String(src));\n    }\n\n    return audio;\n  }\n\n  Object.defineProperty(Audio, \"prototype\", {\n    value: this.HTMLAudioElement.prototype,\n    configurable: false,\n    enumerable: false,\n    writable: false\n  });\n  Object.defineProperty(window, \"Audio\", {\n    value: Audio,\n    configurable: true,\n    enumerable: false,\n    writable: true\n  });\n  this.postMessage = postMessage(window);\n\n  this.atob = function (str) {\n    var result = atob(str);\n\n    if (result === null) {\n      throw DOMException.create(window, [\"The string to be decoded contains invalid characters.\", \"InvalidCharacterError\"]);\n    }\n\n    return result;\n  };\n\n  this.btoa = function (str) {\n    var result = btoa(str);\n\n    if (result === null) {\n      throw DOMException.create(window, [\"The string to be encoded contains invalid characters.\", \"InvalidCharacterError\"]);\n    }\n\n    return result;\n  };\n\n  this.stop = function () {\n    var manager = idlUtils.implForWrapper(this._document)._requestManager;\n\n    if (manager) {\n      manager.close();\n    }\n  };\n\n  this.close = function () {\n    // Recursively close child frame windows, then ourselves (depth-first).\n    for (var i = 0; i < this.length; ++i) {\n      this[i].close();\n    } // Clear out all listeners. Any in-flight or upcoming events should not get delivered.\n\n\n    idlUtils.implForWrapper(this)._eventListeners = Object.create(null);\n\n    if (this._document) {\n      if (this._document.body) {\n        this._document.body.innerHTML = \"\";\n      }\n\n      if (this._document.close) {\n        // It's especially important to clear out the listeners here because document.close() causes a \"load\" event to\n        // fire.\n        idlUtils.implForWrapper(this._document)._eventListeners = Object.create(null);\n\n        this._document.close();\n      }\n\n      var doc = idlUtils.implForWrapper(this._document);\n\n      if (doc._requestManager) {\n        doc._requestManager.close();\n      }\n\n      delete this._document;\n    }\n\n    stopAllTimers();\n    WebSocketImpl.cleanUpWindow(this);\n  };\n\n  this.getComputedStyle = function (elt) {\n    var pseudoElt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    elt = Element.convert(elt);\n\n    if (pseudoElt !== undefined && pseudoElt !== null) {\n      pseudoElt = webIDLConversions.DOMString(pseudoElt);\n    }\n\n    if (pseudoElt !== undefined && pseudoElt !== null && pseudoElt !== \"\") {\n      // TODO: Parse pseudoElt\n      if (SHADOW_DOM_PSEUDO_REGEXP.test(pseudoElt)) {\n        throw new TypeError(\"Tried to get the computed style of a Shadow DOM pseudo-element.\");\n      }\n\n      notImplemented(\"window.computedStyle(elt, pseudoElt)\", this);\n    }\n\n    var declaration = new CSSStyleDeclaration();\n    var forEach = Array.prototype.forEach;\n    var _elt = elt,\n        style = _elt.style;\n    forEachMatchingSheetRuleOfElement(elt, function (rule) {\n      forEach.call(rule.style, function (property) {\n        declaration.setProperty(property, rule.style.getPropertyValue(property), rule.style.getPropertyPriority(property));\n      });\n    }); // https://drafts.csswg.org/cssom/#dom-window-getcomputedstyle\n\n    var declarations = Object.keys(propertiesWithResolvedValueImplemented);\n    forEach.call(declarations, function (property) {\n      declaration.setProperty(property, getResolvedValue(elt, property));\n    });\n    forEach.call(style, function (property) {\n      declaration.setProperty(property, style.getPropertyValue(property), style.getPropertyPriority(property));\n    });\n    return declaration;\n  };\n\n  this.getSelection = function () {\n    return window._document.getSelection();\n  }; // The captureEvents() and releaseEvents() methods must do nothing\n\n\n  this.captureEvents = function () {};\n\n  this.releaseEvents = function () {}; // ### PUBLIC DATA PROPERTIES (TODO: should be getters)\n\n\n  function wrapConsoleMethod(method) {\n    return function () {\n      var _window$_virtualConso;\n\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      (_window$_virtualConso = window._virtualConsole).emit.apply(_window$_virtualConso, [method].concat(args));\n    };\n  }\n\n  this.console = {\n    assert: wrapConsoleMethod(\"assert\"),\n    clear: wrapConsoleMethod(\"clear\"),\n    count: wrapConsoleMethod(\"count\"),\n    countReset: wrapConsoleMethod(\"countReset\"),\n    debug: wrapConsoleMethod(\"debug\"),\n    dir: wrapConsoleMethod(\"dir\"),\n    dirxml: wrapConsoleMethod(\"dirxml\"),\n    error: wrapConsoleMethod(\"error\"),\n    group: wrapConsoleMethod(\"group\"),\n    groupCollapsed: wrapConsoleMethod(\"groupCollapsed\"),\n    groupEnd: wrapConsoleMethod(\"groupEnd\"),\n    info: wrapConsoleMethod(\"info\"),\n    log: wrapConsoleMethod(\"log\"),\n    table: wrapConsoleMethod(\"table\"),\n    time: wrapConsoleMethod(\"time\"),\n    timeLog: wrapConsoleMethod(\"timeLog\"),\n    timeEnd: wrapConsoleMethod(\"timeEnd\"),\n    trace: wrapConsoleMethod(\"trace\"),\n    warn: wrapConsoleMethod(\"warn\")\n  };\n\n  function notImplementedMethod(name) {\n    return function () {\n      notImplemented(name, window);\n    };\n  }\n\n  define(this, {\n    name: \"\",\n    status: \"\",\n    devicePixelRatio: 1,\n    innerWidth: 1024,\n    innerHeight: 768,\n    outerWidth: 1024,\n    outerHeight: 768,\n    pageXOffset: 0,\n    pageYOffset: 0,\n    screenX: 0,\n    screenLeft: 0,\n    screenY: 0,\n    screenTop: 0,\n    scrollX: 0,\n    scrollY: 0,\n    alert: notImplementedMethod(\"window.alert\"),\n    blur: notImplementedMethod(\"window.blur\"),\n    confirm: notImplementedMethod(\"window.confirm\"),\n    focus: notImplementedMethod(\"window.focus\"),\n    moveBy: notImplementedMethod(\"window.moveBy\"),\n    moveTo: notImplementedMethod(\"window.moveTo\"),\n    open: notImplementedMethod(\"window.open\"),\n    print: notImplementedMethod(\"window.print\"),\n    prompt: notImplementedMethod(\"window.prompt\"),\n    resizeBy: notImplementedMethod(\"window.resizeBy\"),\n    resizeTo: notImplementedMethod(\"window.resizeTo\"),\n    scroll: notImplementedMethod(\"window.scroll\"),\n    scrollBy: notImplementedMethod(\"window.scrollBy\"),\n    scrollTo: notImplementedMethod(\"window.scrollTo\")\n  }); // ### INITIALIZATION\n\n  process.nextTick(function () {\n    if (!window.document) {\n      return; // window might've been closed already\n    }\n\n    var documentImpl = idlUtils.implForWrapper(window._document);\n\n    if (window.document.readyState === \"complete\") {\n      fireAnEvent(\"load\", window, undefined, {}, documentImpl);\n    } else {\n      window.document.addEventListener(\"load\", function () {\n        fireAnEvent(\"load\", window, undefined, {}, documentImpl);\n\n        if (!documentImpl._pageShowingFlag) {\n          documentImpl._pageShowingFlag = true;\n          fireAnEvent(\"pageshow\", window, PageTransitionEvent, {\n            persisted: false\n          }, documentImpl);\n        }\n      });\n    }\n  });\n}\n\nfunction contextifyWindow(window) {\n  if (vm.isContext(window)) {\n    return;\n  }\n\n  vm.createContext(window);\n}","map":null,"metadata":{},"sourceType":"script"}