{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _require = require(\"./infra\"),\n    isASCIIHex = _require.isASCIIHex;\n\nvar _require2 = require(\"./encoding\"),\n    utf8Encode = _require2.utf8Encode; // https://url.spec.whatwg.org/#percent-encode\n\n\nfunction percentEncode(c) {\n  var hex = c.toString(16).toUpperCase();\n\n  if (hex.length === 1) {\n    hex = \"0\".concat(hex);\n  }\n\n  return \"%\".concat(hex);\n} // https://url.spec.whatwg.org/#percent-decode\n\n\nfunction percentDecodeBytes(input) {\n  var output = new Uint8Array(input.byteLength);\n  var outputIndex = 0;\n\n  for (var i = 0; i < input.byteLength; ++i) {\n    var byte = input[i];\n\n    if (byte !== 0x25) {\n      output[outputIndex++] = byte;\n    } else if (byte === 0x25 && (!isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2]))) {\n      output[outputIndex++] = byte;\n    } else {\n      var bytePoint = parseInt(String.fromCodePoint(input[i + 1], input[i + 2]), 16);\n      output[outputIndex++] = bytePoint;\n      i += 2;\n    }\n  }\n\n  return output.slice(0, outputIndex);\n} // https://url.spec.whatwg.org/#string-percent-decode\n\n\nfunction percentDecodeString(input) {\n  var bytes = utf8Encode(input);\n  return percentDecodeBytes(bytes);\n} // https://url.spec.whatwg.org/#c0-control-percent-encode-set\n\n\nfunction isC0ControlPercentEncode(c) {\n  return c <= 0x1F || c > 0x7E;\n} // https://url.spec.whatwg.org/#fragment-percent-encode-set\n\n\nvar extraFragmentPercentEncodeSet = new Set([32, 34, 60, 62, 96]);\n\nfunction isFragmentPercentEncode(c) {\n  return isC0ControlPercentEncode(c) || extraFragmentPercentEncodeSet.has(c);\n} // https://url.spec.whatwg.org/#query-percent-encode-set\n\n\nvar extraQueryPercentEncodeSet = new Set([32, 34, 35, 60, 62]);\n\nfunction isQueryPercentEncode(c) {\n  return isC0ControlPercentEncode(c) || extraQueryPercentEncodeSet.has(c);\n} // https://url.spec.whatwg.org/#special-query-percent-encode-set\n\n\nfunction isSpecialQueryPercentEncode(c) {\n  return isQueryPercentEncode(c) || c === 39;\n} // https://url.spec.whatwg.org/#path-percent-encode-set\n\n\nvar extraPathPercentEncodeSet = new Set([63, 96, 123, 125]);\n\nfunction isPathPercentEncode(c) {\n  return isQueryPercentEncode(c) || extraPathPercentEncodeSet.has(c);\n} // https://url.spec.whatwg.org/#userinfo-percent-encode-set\n\n\nvar extraUserinfoPercentEncodeSet = new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);\n\nfunction isUserinfoPercentEncode(c) {\n  return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);\n} // https://url.spec.whatwg.org/#component-percent-encode-set\n\n\nvar extraComponentPercentEncodeSet = new Set([36, 37, 38, 43, 44]);\n\nfunction isComponentPercentEncode(c) {\n  return isUserinfoPercentEncode(c) || extraComponentPercentEncodeSet.has(c);\n} // https://url.spec.whatwg.org/#application-x-www-form-urlencoded-percent-encode-set\n\n\nvar extraURLEncodedPercentEncodeSet = new Set([33, 39, 40, 41, 126]);\n\nfunction isURLEncodedPercentEncode(c) {\n  return isComponentPercentEncode(c) || extraURLEncodedPercentEncodeSet.has(c);\n} // https://url.spec.whatwg.org/#code-point-percent-encode-after-encoding\n// https://url.spec.whatwg.org/#utf-8-percent-encode\n// Assuming encoding is always utf-8 allows us to trim one of the logic branches. TODO: support encoding.\n// The \"-Internal\" variant here has code points as JS strings. The external version used by other files has code points\n// as JS numbers, like the rest of the codebase.\n\n\nfunction utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate) {\n  var bytes = utf8Encode(codePoint);\n  var output = \"\";\n\n  var _iterator = _createForOfIteratorHelper(bytes),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var byte = _step.value;\n\n      // Our percentEncodePredicate operates on bytes, not code points, so this is slightly different from the spec.\n      if (!percentEncodePredicate(byte)) {\n        output += String.fromCharCode(byte);\n      } else {\n        output += percentEncode(byte);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return output;\n}\n\nfunction utf8PercentEncodeCodePoint(codePoint, percentEncodePredicate) {\n  return utf8PercentEncodeCodePointInternal(String.fromCodePoint(codePoint), percentEncodePredicate);\n} // https://url.spec.whatwg.org/#string-percent-encode-after-encoding\n// https://url.spec.whatwg.org/#string-utf-8-percent-encode\n\n\nfunction utf8PercentEncodeString(input, percentEncodePredicate) {\n  var spaceAsPlus = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var output = \"\";\n\n  var _iterator2 = _createForOfIteratorHelper(input),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var codePoint = _step2.value;\n\n      if (spaceAsPlus && codePoint === \" \") {\n        output += \"+\";\n      } else {\n        output += utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return output;\n}\n\nmodule.exports = {\n  isC0ControlPercentEncode: isC0ControlPercentEncode,\n  isFragmentPercentEncode: isFragmentPercentEncode,\n  isQueryPercentEncode: isQueryPercentEncode,\n  isSpecialQueryPercentEncode: isSpecialQueryPercentEncode,\n  isPathPercentEncode: isPathPercentEncode,\n  isUserinfoPercentEncode: isUserinfoPercentEncode,\n  isURLEncodedPercentEncode: isURLEncodedPercentEncode,\n  percentDecodeString: percentDecodeString,\n  percentDecodeBytes: percentDecodeBytes,\n  utf8PercentEncodeString: utf8PercentEncodeString,\n  utf8PercentEncodeCodePoint: utf8PercentEncodeCodePoint\n};","map":null,"metadata":{},"sourceType":"script"}