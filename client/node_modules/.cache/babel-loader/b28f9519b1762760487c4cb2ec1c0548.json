{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _createForOfIteratorHelper = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar DOMException = require(\"domexception/webidl2js-wrapper\");\n\nvar EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\n\nvar _require = require(\"../../utils\"),\n    simultaneousIterators = _require.simultaneousIterators;\n\nvar NODE_TYPE = require(\"../node-type\");\n\nvar NODE_DOCUMENT_POSITION = require(\"../node-document-position\");\n\nvar _require2 = require(\"../node\"),\n    clone = _require2.clone,\n    locateNamespacePrefix = _require2.locateNamespacePrefix,\n    locateNamespace = _require2.locateNamespace;\n\nvar _require3 = require(\"../attributes\"),\n    setAnExistingAttributeValue = _require3.setAnExistingAttributeValue;\n\nvar NodeList = require(\"../generated/NodeList\");\n\nvar _require4 = require(\"../helpers/node\"),\n    nodeRoot = _require4.nodeRoot,\n    nodeLength = _require4.nodeLength;\n\nvar _require5 = require(\"../helpers/internal-constants\"),\n    domSymbolTree = _require5.domSymbolTree;\n\nvar _require6 = require(\"../helpers/document-base-url\"),\n    documentBaseURLSerialized = _require6.documentBaseURLSerialized;\n\nvar _require7 = require(\"../helpers/mutation-observers\"),\n    queueTreeMutationRecord = _require7.queueTreeMutationRecord;\n\nvar _require8 = require(\"../helpers/custom-elements\"),\n    enqueueCECallbackReaction = _require8.enqueueCECallbackReaction,\n    tryUpgradeElement = _require8.tryUpgradeElement;\n\nvar _require9 = require(\"../helpers/shadow-dom\"),\n    isShadowRoot = _require9.isShadowRoot,\n    shadowIncludingRoot = _require9.shadowIncludingRoot,\n    assignSlot = _require9.assignSlot,\n    assignSlotableForTree = _require9.assignSlotableForTree,\n    assignSlotable = _require9.assignSlotable,\n    signalSlotChange = _require9.signalSlotChange,\n    isSlot = _require9.isSlot,\n    shadowIncludingInclusiveDescendantsIterator = _require9.shadowIncludingInclusiveDescendantsIterator,\n    shadowIncludingDescendantsIterator = _require9.shadowIncludingDescendantsIterator;\n\nfunction isObsoleteNodeType(node) {\n  return node.nodeType === NODE_TYPE.ENTITY_NODE || node.nodeType === NODE_TYPE.ENTITY_REFERENCE_NODE || node.nodeType === NODE_TYPE.NOTATION_NODE || node.nodeType === NODE_TYPE.CDATA_SECTION_NODE;\n}\n\nfunction nodeEquals(a, b) {\n  if (a.nodeType !== b.nodeType) {\n    return false;\n  }\n\n  switch (a.nodeType) {\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      if (a.name !== b.name || a.publicId !== b.publicId || a.systemId !== b.systemId) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.ELEMENT_NODE:\n      if (a._namespaceURI !== b._namespaceURI || a._prefix !== b._prefix || a._localName !== b._localName || a._attributes.length !== b._attributes.length) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.ATTRIBUTE_NODE:\n      if (a._namespace !== b._namespace || a._localName !== b._localName || a._value !== b._value) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      if (a._target !== b._target || a._data !== b._data) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.TEXT_NODE:\n    case NODE_TYPE.COMMENT_NODE:\n      if (a._data !== b._data) {\n        return false;\n      }\n\n      break;\n  }\n\n  if (a.nodeType === NODE_TYPE.ELEMENT_NODE && !attributeListsEqual(a, b)) {\n    return false;\n  }\n\n  var _iterator = _createForOfIteratorHelper(simultaneousIterators(domSymbolTree.childrenIterator(a), domSymbolTree.childrenIterator(b))),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var nodes = _step.value;\n\n      if (!nodes[0] || !nodes[1]) {\n        // mismatch in the amount of childNodes\n        return false;\n      }\n\n      if (!nodeEquals(nodes[0], nodes[1])) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return true;\n} // Needed by https://dom.spec.whatwg.org/#concept-node-equals\n\n\nfunction attributeListsEqual(elementA, elementB) {\n  var listA = elementA._attributeList;\n  var listB = elementB._attributeList;\n  var lengthA = listA.length;\n  var lengthB = listB.length;\n\n  if (lengthA !== lengthB) {\n    return false;\n  }\n\n  var _loop = function _loop(i) {\n    var attrA = listA[i];\n\n    if (!listB.some(function (attrB) {\n      return nodeEquals(attrA, attrB);\n    })) {\n      return {\n        v: false\n      };\n    }\n  };\n\n  for (var i = 0; i < lengthA; ++i) {\n    var _ret = _loop(i);\n\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n\n  return true;\n} // https://dom.spec.whatwg.org/#concept-tree-host-including-inclusive-ancestor\n\n\nfunction isHostInclusiveAncestor(nodeImplA, nodeImplB) {\n  var _iterator2 = _createForOfIteratorHelper(domSymbolTree.ancestorsIterator(nodeImplB)),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var ancestor = _step2.value;\n\n      if (ancestor === nodeImplA) {\n        return true;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var rootImplB = nodeRoot(nodeImplB);\n\n  if (rootImplB._host) {\n    return isHostInclusiveAncestor(nodeImplA, rootImplB._host);\n  }\n\n  return false;\n}\n\nvar NodeImpl = /*#__PURE__*/function (_EventTargetImpl) {\n  _inherits(NodeImpl, _EventTargetImpl);\n\n  var _super = _createSuper(NodeImpl);\n\n  function NodeImpl(globalObject, args, privateData) {\n    var _this;\n\n    _classCallCheck(this, NodeImpl);\n\n    _this = _super.call(this, globalObject, args, privateData);\n    domSymbolTree.initialize(_assertThisInitialized(_this));\n    _this._ownerDocument = privateData.ownerDocument;\n    _this._childNodesList = null;\n    _this._childrenList = null;\n    _this._version = 0;\n    _this._memoizedQueries = {};\n    _this._registeredObserverList = [];\n    _this._referencedRanges = new Set();\n    return _this;\n  }\n\n  _createClass(NodeImpl, [{\n    key: \"_getTheParent\",\n    value: function _getTheParent() {\n      if (this._assignedSlot) {\n        return this._assignedSlot;\n      }\n\n      return domSymbolTree.parent(this);\n    }\n  }, {\n    key: \"parentNode\",\n    get: function get() {\n      return domSymbolTree.parent(this);\n    }\n  }, {\n    key: \"getRootNode\",\n    value: function getRootNode(options) {\n      return options.composed ? shadowIncludingRoot(this) : nodeRoot(this);\n    }\n  }, {\n    key: \"nodeName\",\n    get: function get() {\n      switch (this.nodeType) {\n        case NODE_TYPE.ELEMENT_NODE:\n          return this.tagName;\n\n        case NODE_TYPE.ATTRIBUTE_NODE:\n          return this._qualifiedName;\n\n        case NODE_TYPE.TEXT_NODE:\n          return \"#text\";\n\n        case NODE_TYPE.CDATA_SECTION_NODE:\n          return \"#cdata-section\";\n\n        case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n          return this.target;\n\n        case NODE_TYPE.COMMENT_NODE:\n          return \"#comment\";\n\n        case NODE_TYPE.DOCUMENT_NODE:\n          return \"#document\";\n\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n          return this.name;\n\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n          return \"#document-fragment\";\n      } // should never happen\n\n\n      return null;\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return domSymbolTree.firstChild(this);\n    } // https://dom.spec.whatwg.org/#connected\n    // https://dom.spec.whatwg.org/#dom-node-isconnected\n\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      var root = shadowIncludingRoot(this);\n      return root && root.nodeType === NODE_TYPE.DOCUMENT_NODE;\n    }\n  }, {\n    key: \"ownerDocument\",\n    get: function get() {\n      return this.nodeType === NODE_TYPE.DOCUMENT_NODE ? null : this._ownerDocument;\n    }\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return domSymbolTree.lastChild(this);\n    }\n  }, {\n    key: \"childNodes\",\n    get: function get() {\n      var _this2 = this;\n\n      if (!this._childNodesList) {\n        this._childNodesList = NodeList.createImpl(this._globalObject, [], {\n          element: this,\n          query: function query() {\n            return domSymbolTree.childrenToArray(_this2);\n          }\n        });\n      } else {\n        this._childNodesList._update();\n      }\n\n      return this._childNodesList;\n    }\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      return domSymbolTree.nextSibling(this);\n    }\n  }, {\n    key: \"previousSibling\",\n    get: function get() {\n      return domSymbolTree.previousSibling(this);\n    }\n  }, {\n    key: \"_modified\",\n    value: function _modified() {\n      this._version++;\n\n      var _iterator3 = _createForOfIteratorHelper(domSymbolTree.ancestorsIterator(this)),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var ancestor = _step3.value;\n          ancestor._version++;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      if (this._childrenList) {\n        this._childrenList._update();\n      }\n\n      if (this._childNodesList) {\n        this._childNodesList._update();\n      }\n\n      this._clearMemoizedQueries();\n    }\n  }, {\n    key: \"_childTextContentChangeSteps\",\n    value: function _childTextContentChangeSteps() {// Default: do nothing\n    }\n  }, {\n    key: \"_clearMemoizedQueries\",\n    value: function _clearMemoizedQueries() {\n      this._memoizedQueries = {};\n      var myParent = domSymbolTree.parent(this);\n\n      if (myParent) {\n        myParent._clearMemoizedQueries();\n      }\n    }\n  }, {\n    key: \"_descendantRemoved\",\n    value: function _descendantRemoved(parent, child) {\n      var myParent = domSymbolTree.parent(this);\n\n      if (myParent) {\n        myParent._descendantRemoved(parent, child);\n      }\n    }\n  }, {\n    key: \"_descendantAdded\",\n    value: function _descendantAdded(parent, child) {\n      var myParent = domSymbolTree.parent(this);\n\n      if (myParent) {\n        myParent._descendantAdded(parent, child);\n      }\n    }\n  }, {\n    key: \"_attach\",\n    value: function _attach() {\n      this._attached = true;\n\n      var _iterator4 = _createForOfIteratorHelper(domSymbolTree.childrenIterator(this)),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var child = _step4.value;\n\n          if (child._attach) {\n            child._attach();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"_detach\",\n    value: function _detach() {\n      this._attached = false;\n\n      if (this._ownerDocument && this._ownerDocument._lastFocusedElement === this) {\n        this._ownerDocument._lastFocusedElement = null;\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(domSymbolTree.childrenIterator(this)),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var child = _step5.value;\n\n          if (child._detach) {\n            child._detach();\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  }, {\n    key: \"hasChildNodes\",\n    value: function hasChildNodes() {\n      return domSymbolTree.hasChildren(this);\n    } // https://dom.spec.whatwg.org/#dom-node-normalize\n\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      // It is important to use a treeToArray instead of a treeToIterator here, because the\n      // treeToIterator doesn't support tree mutation in the middle of the traversal.\n      var _iterator6 = _createForOfIteratorHelper(domSymbolTree.treeToArray(this)),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var node = _step6.value;\n          var parentNode = domSymbolTree.parent(node);\n\n          if (parentNode === null || node.nodeType !== NODE_TYPE.TEXT_NODE) {\n            continue;\n          }\n\n          var length = nodeLength(node);\n\n          if (length === 0) {\n            parentNode._remove(node);\n\n            continue;\n          }\n\n          var continuousExclusiveTextNodes = [];\n\n          var _iterator7 = _createForOfIteratorHelper(domSymbolTree.previousSiblingsIterator(node)),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var _currentNode = _step7.value;\n\n              if (_currentNode.nodeType !== NODE_TYPE.TEXT_NODE) {\n                break;\n              }\n\n              continuousExclusiveTextNodes.unshift(_currentNode);\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n\n          var _iterator8 = _createForOfIteratorHelper(domSymbolTree.nextSiblingsIterator(node)),\n              _step8;\n\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var _currentNode2 = _step8.value;\n\n              if (_currentNode2.nodeType !== NODE_TYPE.TEXT_NODE) {\n                break;\n              }\n\n              continuousExclusiveTextNodes.push(_currentNode2);\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n\n          var data = continuousExclusiveTextNodes.reduce(function (d, n) {\n            return d + n._data;\n          }, \"\");\n          node.replaceData(length, 0, data);\n          var currentNode = domSymbolTree.nextSibling(node);\n\n          while (currentNode && currentNode.nodeType !== NODE_TYPE.TEXT_NODE) {\n            var currentNodeParent = domSymbolTree.parent(currentNode);\n            var currentNodeIndex = domSymbolTree.index(currentNode);\n\n            var _iterator9 = _createForOfIteratorHelper(node._referencedRanges),\n                _step9;\n\n            try {\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                var range = _step9.value;\n                var _start = range._start,\n                    _end = range._end;\n\n                if (_start.node === currentNode) {\n                  range._setLiveRangeStart(node, _start.offset + length);\n                }\n\n                if (_end.node === currentNode) {\n                  range._setLiveRangeEnd(node, _end.offset + length);\n                }\n\n                if (_start.node === currentNodeParent && _start.offset === currentNodeIndex) {\n                  range._setLiveRangeStart(node, length);\n                }\n\n                if (_end.node === currentNodeParent && _end.offset === currentNodeIndex) {\n                  range._setLiveRangeStart(node, length);\n                }\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n\n            length += nodeLength(currentNode);\n            currentNode = domSymbolTree.nextSibling(currentNode);\n          }\n\n          for (var _i = 0, _continuousExclusiveT = continuousExclusiveTextNodes; _i < _continuousExclusiveT.length; _i++) {\n            var continuousExclusiveTextNode = _continuousExclusiveT[_i];\n\n            parentNode._remove(continuousExclusiveTextNode);\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  }, {\n    key: \"parentElement\",\n    get: function get() {\n      var parentNode = domSymbolTree.parent(this);\n      return parentNode !== null && parentNode.nodeType === NODE_TYPE.ELEMENT_NODE ? parentNode : null;\n    }\n  }, {\n    key: \"baseURI\",\n    get: function get() {\n      return documentBaseURLSerialized(this._ownerDocument);\n    }\n  }, {\n    key: \"compareDocumentPosition\",\n    value: function compareDocumentPosition(other) {\n      // Let node1 be other and node2 be the context object.\n      var node1 = other;\n      var node2 = this;\n\n      if (isObsoleteNodeType(node2) || isObsoleteNodeType(node1)) {\n        throw new Error(\"Obsolete node type\");\n      }\n\n      var attr1 = null;\n      var attr2 = null;\n\n      if (node1.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n        attr1 = node1;\n        node1 = attr1._element;\n      }\n\n      if (node2.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n        attr2 = node2;\n        node2 = attr2._element;\n\n        if (attr1 !== null && node1 !== null && node2 === node1) {\n          var _iterator10 = _createForOfIteratorHelper(node2._attributeList),\n              _step10;\n\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var attr = _step10.value;\n\n              if (nodeEquals(attr, attr1)) {\n                return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_PRECEDING;\n              }\n\n              if (nodeEquals(attr, attr2)) {\n                return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n              }\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n        }\n      }\n\n      var result = domSymbolTree.compareTreePosition(node2, node1); // “If other and reference are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n      //  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or\n      // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.”\n\n      if (result === NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED) {\n        // symbol-tree does not add these bits required by the spec:\n        return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"lookupPrefix\",\n    value: function lookupPrefix(namespace) {\n      if (namespace === null || namespace === \"\") {\n        return null;\n      }\n\n      switch (this.nodeType) {\n        case NODE_TYPE.ELEMENT_NODE:\n          {\n            return locateNamespacePrefix(this, namespace);\n          }\n\n        case NODE_TYPE.DOCUMENT_NODE:\n          {\n            return this.documentElement !== null ? locateNamespacePrefix(this.documentElement, namespace) : null;\n          }\n\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n          {\n            return null;\n          }\n\n        case NODE_TYPE.ATTRIBUTE_NODE:\n          {\n            return this._element !== null ? locateNamespacePrefix(this._element, namespace) : null;\n          }\n\n        default:\n          {\n            return this.parentElement !== null ? locateNamespacePrefix(this.parentElement, namespace) : null;\n          }\n      }\n    }\n  }, {\n    key: \"lookupNamespaceURI\",\n    value: function lookupNamespaceURI(prefix) {\n      if (prefix === \"\") {\n        prefix = null;\n      }\n\n      return locateNamespace(this, prefix);\n    }\n  }, {\n    key: \"isDefaultNamespace\",\n    value: function isDefaultNamespace(namespace) {\n      if (namespace === \"\") {\n        namespace = null;\n      }\n\n      var defaultNamespace = locateNamespace(this, null);\n      return defaultNamespace === namespace;\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(other) {\n      if (other === null) {\n        return false;\n      } else if (this === other) {\n        return true;\n      }\n\n      return Boolean(this.compareDocumentPosition(other) & NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_CONTAINED_BY);\n    }\n  }, {\n    key: \"isEqualNode\",\n    value: function isEqualNode(node) {\n      if (node === null) {\n        return false;\n      } // Fast-path, not in the spec\n\n\n      if (this === node) {\n        return true;\n      }\n\n      return nodeEquals(this, node);\n    }\n  }, {\n    key: \"isSameNode\",\n    value: function isSameNode(node) {\n      if (this === node) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"cloneNode\",\n    value: function cloneNode(deep) {\n      if (isShadowRoot(this)) {\n        throw DOMException.create(this._globalObject, [\"ShadowRoot nodes are not clonable.\", \"NotSupportedError\"]);\n      }\n\n      deep = Boolean(deep);\n      return clone(this, undefined, deep);\n    }\n  }, {\n    key: \"nodeValue\",\n    get: function get() {\n      switch (this.nodeType) {\n        case NODE_TYPE.ATTRIBUTE_NODE:\n          {\n            return this._value;\n          }\n\n        case NODE_TYPE.TEXT_NODE:\n        case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n        case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        case NODE_TYPE.COMMENT_NODE:\n          {\n            return this._data;\n          }\n\n        default:\n          {\n            return null;\n          }\n      }\n    },\n    set: function set(value) {\n      if (value === null) {\n        value = \"\";\n      }\n\n      switch (this.nodeType) {\n        case NODE_TYPE.ATTRIBUTE_NODE:\n          {\n            setAnExistingAttributeValue(this, value);\n            break;\n          }\n\n        case NODE_TYPE.TEXT_NODE:\n        case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n        case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        case NODE_TYPE.COMMENT_NODE:\n          {\n            this.replaceData(0, this.length, value);\n            break;\n          }\n      }\n    } // https://dom.spec.whatwg.org/#dom-node-textcontent\n\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      switch (this.nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        case NODE_TYPE.ELEMENT_NODE:\n          {\n            var text = \"\";\n\n            var _iterator11 = _createForOfIteratorHelper(domSymbolTree.treeIterator(this)),\n                _step11;\n\n            try {\n              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                var child = _step11.value;\n\n                if (child.nodeType === NODE_TYPE.TEXT_NODE || child.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n                  text += child.nodeValue;\n                }\n              }\n            } catch (err) {\n              _iterator11.e(err);\n            } finally {\n              _iterator11.f();\n            }\n\n            return text;\n          }\n\n        case NODE_TYPE.ATTRIBUTE_NODE:\n          {\n            return this._value;\n          }\n\n        case NODE_TYPE.TEXT_NODE:\n        case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n        case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        case NODE_TYPE.COMMENT_NODE:\n          {\n            return this._data;\n          }\n\n        default:\n          {\n            return null;\n          }\n      }\n    },\n    set: function set(value) {\n      if (value === null) {\n        value = \"\";\n      }\n\n      switch (this.nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        case NODE_TYPE.ELEMENT_NODE:\n          {\n            // https://dom.spec.whatwg.org/#string-replace-all\n            var nodeImpl = null;\n\n            if (value !== \"\") {\n              nodeImpl = this._ownerDocument.createTextNode(value);\n            }\n\n            this._replaceAll(nodeImpl);\n\n            break;\n          }\n\n        case NODE_TYPE.ATTRIBUTE_NODE:\n          {\n            setAnExistingAttributeValue(this, value);\n            break;\n          }\n\n        case NODE_TYPE.TEXT_NODE:\n        case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n        case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        case NODE_TYPE.COMMENT_NODE:\n          {\n            this.replaceData(0, this.length, value);\n            break;\n          }\n      }\n    } // https://dom.spec.whatwg.org/#dom-node-insertbefore\n\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(nodeImpl, childImpl) {\n      return this._preInsert(nodeImpl, childImpl);\n    } // https://dom.spec.whatwg.org/#dom-node-appendchild\n\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(nodeImpl) {\n      return this._append(nodeImpl);\n    } // https://dom.spec.whatwg.org/#dom-node-replacechild\n\n  }, {\n    key: \"replaceChild\",\n    value: function replaceChild(nodeImpl, childImpl) {\n      return this._replace(nodeImpl, childImpl);\n    } // https://dom.spec.whatwg.org/#dom-node-removechild\n\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(oldChildImpl) {\n      return this._preRemove(oldChildImpl);\n    } // https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n\n  }, {\n    key: \"_preInsertValidity\",\n    value: function _preInsertValidity(nodeImpl, childImpl) {\n      var nodeType = nodeImpl.nodeType,\n          nodeName = nodeImpl.nodeName;\n      var parentType = this.nodeType,\n          parentName = this.nodeName;\n\n      if (parentType !== NODE_TYPE.DOCUMENT_NODE && parentType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && parentType !== NODE_TYPE.ELEMENT_NODE) {\n        throw DOMException.create(this._globalObject, [\"Node can't be inserted in a \".concat(parentName, \" parent.\"), \"HierarchyRequestError\"]);\n      }\n\n      if (isHostInclusiveAncestor(nodeImpl, this)) {\n        throw DOMException.create(this._globalObject, [\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\"]);\n      }\n\n      if (childImpl && domSymbolTree.parent(childImpl) !== this) {\n        throw DOMException.create(this._globalObject, [\"The child can not be found in the parent.\", \"NotFoundError\"]);\n      }\n\n      if (nodeType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && nodeType !== NODE_TYPE.DOCUMENT_TYPE_NODE && nodeType !== NODE_TYPE.ELEMENT_NODE && nodeType !== NODE_TYPE.TEXT_NODE && nodeType !== NODE_TYPE.CDATA_SECTION_NODE && // CData section extends from Text\n      nodeType !== NODE_TYPE.PROCESSING_INSTRUCTION_NODE && nodeType !== NODE_TYPE.COMMENT_NODE) {\n        throw DOMException.create(this._globalObject, [\"\".concat(nodeName, \" node can't be inserted in parent node.\"), \"HierarchyRequestError\"]);\n      }\n\n      if (nodeType === NODE_TYPE.TEXT_NODE && parentType === NODE_TYPE.DOCUMENT_NODE || nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && parentType !== NODE_TYPE.DOCUMENT_NODE) {\n        throw DOMException.create(this._globalObject, [\"\".concat(nodeName, \" node can't be inserted in \").concat(parentName, \" parent.\"), \"HierarchyRequestError\"]);\n      }\n\n      if (parentType === NODE_TYPE.DOCUMENT_NODE) {\n        var nodeChildren = domSymbolTree.childrenToArray(nodeImpl);\n        var parentChildren = domSymbolTree.childrenToArray(this);\n\n        switch (nodeType) {\n          case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n            {\n              var nodeChildrenElements = nodeChildren.filter(function (child) {\n                return child.nodeType === NODE_TYPE.ELEMENT_NODE;\n              });\n\n              if (nodeChildrenElements.length > 1) {\n                throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n              }\n\n              var hasNodeTextChildren = nodeChildren.some(function (child) {\n                return child.nodeType === NODE_TYPE.TEXT_NODE;\n              });\n\n              if (hasNodeTextChildren) {\n                throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n              }\n\n              if (nodeChildrenElements.length === 1 && (parentChildren.some(function (child) {\n                return child.nodeType === NODE_TYPE.ELEMENT_NODE;\n              }) || childImpl && childImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE)) {\n                throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n              }\n\n              break;\n            }\n\n          case NODE_TYPE.ELEMENT_NODE:\n            if (parentChildren.some(function (child) {\n              return child.nodeType === NODE_TYPE.ELEMENT_NODE;\n            }) || childImpl && childImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n              throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n            }\n\n            break;\n\n          case NODE_TYPE.DOCUMENT_TYPE_NODE:\n            if (parentChildren.some(function (child) {\n              return child.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE;\n            }) || childImpl && domSymbolTree.previousSibling(childImpl) && domSymbolTree.previousSibling(childImpl).nodeType === NODE_TYPE.ELEMENT_NODE || !childImpl && parentChildren.some(function (child) {\n              return child.nodeType === NODE_TYPE.ELEMENT_NODE;\n            })) {\n              throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n            }\n\n            break;\n        }\n      }\n    } // https://dom.spec.whatwg.org/#concept-node-pre-insert\n\n  }, {\n    key: \"_preInsert\",\n    value: function _preInsert(nodeImpl, childImpl) {\n      this._preInsertValidity(nodeImpl, childImpl);\n\n      var referenceChildImpl = childImpl;\n\n      if (referenceChildImpl === nodeImpl) {\n        referenceChildImpl = domSymbolTree.nextSibling(nodeImpl);\n      }\n\n      this._ownerDocument._adoptNode(nodeImpl);\n\n      this._insert(nodeImpl, referenceChildImpl);\n\n      return nodeImpl;\n    } // https://dom.spec.whatwg.org/#concept-node-insert\n\n  }, {\n    key: \"_insert\",\n    value: function _insert(nodeImpl, childImpl, suppressObservers) {\n      var count = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? domSymbolTree.childrenCount(nodeImpl) : 1;\n\n      if (childImpl) {\n        var childIndex = domSymbolTree.index(childImpl);\n\n        var _iterator12 = _createForOfIteratorHelper(this._referencedRanges),\n            _step12;\n\n        try {\n          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n            var range = _step12.value;\n            var _start = range._start,\n                _end = range._end;\n\n            if (_start.offset > childIndex) {\n              range._setLiveRangeStart(this, _start.offset + count);\n            }\n\n            if (_end.offset > childIndex) {\n              range._setLiveRangeEnd(this, _end.offset + count);\n            }\n          }\n        } catch (err) {\n          _iterator12.e(err);\n        } finally {\n          _iterator12.f();\n        }\n      }\n\n      var nodesImpl = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? domSymbolTree.childrenToArray(nodeImpl) : [nodeImpl];\n\n      if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n        var grandChildImpl;\n\n        while (grandChildImpl = domSymbolTree.firstChild(nodeImpl)) {\n          nodeImpl._remove(grandChildImpl, true);\n        }\n      }\n\n      if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n        queueTreeMutationRecord(nodeImpl, [], nodesImpl, null, null);\n      }\n\n      var previousChildImpl = childImpl ? domSymbolTree.previousSibling(childImpl) : domSymbolTree.lastChild(this);\n\n      var _iterator13 = _createForOfIteratorHelper(nodesImpl),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var node = _step13.value;\n\n          if (!childImpl) {\n            domSymbolTree.appendChild(this, node);\n          } else {\n            domSymbolTree.insertBefore(childImpl, node);\n          }\n\n          if (this.nodeType === NODE_TYPE.ELEMENT_NODE && this._shadowRoot !== null && (node.nodeType === NODE_TYPE.ELEMENT_NODE || node.nodeType === NODE_TYPE.TEXT_NODE)) {\n            assignSlot(node);\n          }\n\n          this._modified();\n\n          if (node.nodeType === NODE_TYPE.TEXT_NODE || node.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n            this._childTextContentChangeSteps();\n          }\n\n          if (isSlot(this) && this._assignedNodes.length === 0 && isShadowRoot(nodeRoot(this))) {\n            signalSlotChange(this);\n          }\n\n          var root = nodeRoot(node);\n\n          if (isShadowRoot(root)) {\n            assignSlotableForTree(root);\n          }\n\n          if (this._attached && nodeImpl._attach) {\n            node._attach();\n          }\n\n          this._descendantAdded(this, node);\n\n          var _iterator14 = _createForOfIteratorHelper(shadowIncludingInclusiveDescendantsIterator(node)),\n              _step14;\n\n          try {\n            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n              var inclusiveDescendant = _step14.value;\n\n              if (inclusiveDescendant.isConnected) {\n                if (inclusiveDescendant._ceState === \"custom\") {\n                  enqueueCECallbackReaction(inclusiveDescendant, \"connectedCallback\", []);\n                } else {\n                  tryUpgradeElement(inclusiveDescendant);\n                }\n              }\n            }\n          } catch (err) {\n            _iterator14.e(err);\n          } finally {\n            _iterator14.f();\n          }\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      if (!suppressObservers) {\n        queueTreeMutationRecord(this, nodesImpl, [], previousChildImpl, childImpl);\n      }\n    } // https://dom.spec.whatwg.org/#concept-node-append\n\n  }, {\n    key: \"_append\",\n    value: function _append(nodeImpl) {\n      return this._preInsert(nodeImpl, null);\n    } // https://dom.spec.whatwg.org/#concept-node-replace\n\n  }, {\n    key: \"_replace\",\n    value: function _replace(nodeImpl, childImpl) {\n      var nodeType = nodeImpl.nodeType,\n          nodeName = nodeImpl.nodeName;\n      var parentType = this.nodeType,\n          parentName = this.nodeName; // Note: This section differs from the pre-insert validation algorithm.\n\n      if (parentType !== NODE_TYPE.DOCUMENT_NODE && parentType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && parentType !== NODE_TYPE.ELEMENT_NODE) {\n        throw DOMException.create(this._globalObject, [\"Node can't be inserted in a \".concat(parentName, \" parent.\"), \"HierarchyRequestError\"]);\n      }\n\n      if (isHostInclusiveAncestor(nodeImpl, this)) {\n        throw DOMException.create(this._globalObject, [\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\"]);\n      }\n\n      if (childImpl && domSymbolTree.parent(childImpl) !== this) {\n        throw DOMException.create(this._globalObject, [\"The child can not be found in the parent.\", \"NotFoundError\"]);\n      }\n\n      if (nodeType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && nodeType !== NODE_TYPE.DOCUMENT_TYPE_NODE && nodeType !== NODE_TYPE.ELEMENT_NODE && nodeType !== NODE_TYPE.TEXT_NODE && nodeType !== NODE_TYPE.CDATA_SECTION_NODE && // CData section extends from Text\n      nodeType !== NODE_TYPE.PROCESSING_INSTRUCTION_NODE && nodeType !== NODE_TYPE.COMMENT_NODE) {\n        throw DOMException.create(this._globalObject, [\"\".concat(nodeName, \" node can't be inserted in parent node.\"), \"HierarchyRequestError\"]);\n      }\n\n      if (nodeType === NODE_TYPE.TEXT_NODE && parentType === NODE_TYPE.DOCUMENT_NODE || nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && parentType !== NODE_TYPE.DOCUMENT_NODE) {\n        throw DOMException.create(this._globalObject, [\"\".concat(nodeName, \" node can't be inserted in \").concat(parentName, \" parent.\"), \"HierarchyRequestError\"]);\n      }\n\n      if (parentType === NODE_TYPE.DOCUMENT_NODE) {\n        var nodeChildren = domSymbolTree.childrenToArray(nodeImpl);\n        var parentChildren = domSymbolTree.childrenToArray(this);\n\n        switch (nodeType) {\n          case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n            {\n              var nodeChildrenElements = nodeChildren.filter(function (child) {\n                return child.nodeType === NODE_TYPE.ELEMENT_NODE;\n              });\n\n              if (nodeChildrenElements.length > 1) {\n                throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n              }\n\n              var hasNodeTextChildren = nodeChildren.some(function (child) {\n                return child.nodeType === NODE_TYPE.TEXT_NODE;\n              });\n\n              if (hasNodeTextChildren) {\n                throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n              }\n\n              var parentChildElements = parentChildren.filter(function (child) {\n                return child.nodeType === NODE_TYPE.ELEMENT_NODE;\n              });\n\n              if (nodeChildrenElements.length === 1 && (parentChildElements.length === 1 && parentChildElements[0] !== childImpl || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE)) {\n                throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n              }\n\n              break;\n            }\n\n          case NODE_TYPE.ELEMENT_NODE:\n            if (parentChildren.some(function (child) {\n              return child.nodeType === NODE_TYPE.ELEMENT_NODE && child !== childImpl;\n            }) || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n              throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n            }\n\n            break;\n\n          case NODE_TYPE.DOCUMENT_TYPE_NODE:\n            if (parentChildren.some(function (child) {\n              return child.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && child !== childImpl;\n            }) || childImpl && domSymbolTree.previousSibling(childImpl) && domSymbolTree.previousSibling(childImpl).nodeType === NODE_TYPE.ELEMENT_NODE) {\n              throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n            }\n\n            break;\n        }\n      }\n\n      var referenceChildImpl = domSymbolTree.nextSibling(childImpl);\n\n      if (referenceChildImpl === nodeImpl) {\n        referenceChildImpl = domSymbolTree.nextSibling(nodeImpl);\n      }\n\n      var previousSiblingImpl = domSymbolTree.previousSibling(childImpl);\n\n      this._ownerDocument._adoptNode(nodeImpl);\n\n      var removedNodesImpl = [];\n\n      if (domSymbolTree.parent(childImpl)) {\n        removedNodesImpl = [childImpl];\n\n        this._remove(childImpl, true);\n      }\n\n      var nodesImpl = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? domSymbolTree.childrenToArray(nodeImpl) : [nodeImpl];\n\n      this._insert(nodeImpl, referenceChildImpl, true);\n\n      queueTreeMutationRecord(this, nodesImpl, removedNodesImpl, previousSiblingImpl, referenceChildImpl);\n      return childImpl;\n    } // https://dom.spec.whatwg.org/#concept-node-replace-all\n\n  }, {\n    key: \"_replaceAll\",\n    value: function _replaceAll(nodeImpl) {\n      if (nodeImpl !== null) {\n        this._ownerDocument._adoptNode(nodeImpl);\n      }\n\n      var removedNodesImpl = domSymbolTree.childrenToArray(this);\n      var addedNodesImpl;\n\n      if (nodeImpl === null) {\n        addedNodesImpl = [];\n      } else if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n        addedNodesImpl = domSymbolTree.childrenToArray(nodeImpl);\n      } else {\n        addedNodesImpl = [nodeImpl];\n      }\n\n      var _iterator15 = _createForOfIteratorHelper(domSymbolTree.childrenIterator(this)),\n          _step15;\n\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var childImpl = _step15.value;\n\n          this._remove(childImpl, true);\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n\n      if (nodeImpl !== null) {\n        this._insert(nodeImpl, null, true);\n      }\n\n      if (addedNodesImpl.length > 0 || removedNodesImpl.length > 0) {\n        queueTreeMutationRecord(this, addedNodesImpl, removedNodesImpl, null, null);\n      }\n    } // https://dom.spec.whatwg.org/#concept-node-pre-remove\n\n  }, {\n    key: \"_preRemove\",\n    value: function _preRemove(childImpl) {\n      if (domSymbolTree.parent(childImpl) !== this) {\n        throw DOMException.create(this._globalObject, [\"The node to be removed is not a child of this node.\", \"NotFoundError\"]);\n      }\n\n      this._remove(childImpl);\n\n      return childImpl;\n    } // https://dom.spec.whatwg.org/#concept-node-remove\n\n  }, {\n    key: \"_remove\",\n    value: function _remove(nodeImpl, suppressObservers) {\n      var index = domSymbolTree.index(nodeImpl);\n\n      var _iterator16 = _createForOfIteratorHelper(domSymbolTree.treeIterator(nodeImpl)),\n          _step16;\n\n      try {\n        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n          var descendant = _step16.value;\n\n          var _iterator20 = _createForOfIteratorHelper(descendant._referencedRanges),\n              _step20;\n\n          try {\n            for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n              var range = _step20.value;\n              var _start = range._start,\n                  _end = range._end;\n\n              if (_start.node === descendant) {\n                range._setLiveRangeStart(this, index);\n              }\n\n              if (_end.node === descendant) {\n                range._setLiveRangeEnd(this, index);\n              }\n            }\n          } catch (err) {\n            _iterator20.e(err);\n          } finally {\n            _iterator20.f();\n          }\n        }\n      } catch (err) {\n        _iterator16.e(err);\n      } finally {\n        _iterator16.f();\n      }\n\n      var _iterator17 = _createForOfIteratorHelper(this._referencedRanges),\n          _step17;\n\n      try {\n        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n          var _range = _step17.value;\n          var _start2 = _range._start,\n              _end2 = _range._end;\n\n          if (_start2.node === this && _start2.offset > index) {\n            _range._setLiveRangeStart(this, _start2.offset - 1);\n          }\n\n          if (_end2.node === this && _end2.offset > index) {\n            _range._setLiveRangeEnd(this, _end2.offset - 1);\n          }\n        }\n      } catch (err) {\n        _iterator17.e(err);\n      } finally {\n        _iterator17.f();\n      }\n\n      if (this._ownerDocument) {\n        this._ownerDocument._runPreRemovingSteps(nodeImpl);\n      }\n\n      var oldPreviousSiblingImpl = domSymbolTree.previousSibling(nodeImpl);\n      var oldNextSiblingImpl = domSymbolTree.nextSibling(nodeImpl);\n      domSymbolTree.remove(nodeImpl);\n\n      if (nodeImpl._assignedSlot) {\n        assignSlotable(nodeImpl._assignedSlot);\n      }\n\n      if (isSlot(this) && this._assignedNodes.length === 0 && isShadowRoot(nodeRoot(this))) {\n        signalSlotChange(this);\n      }\n\n      var hasSlotDescendant = isSlot(nodeImpl);\n\n      if (!hasSlotDescendant) {\n        var _iterator18 = _createForOfIteratorHelper(domSymbolTree.treeIterator(nodeImpl)),\n            _step18;\n\n        try {\n          for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n            var child = _step18.value;\n\n            if (isSlot(child)) {\n              hasSlotDescendant = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator18.e(err);\n        } finally {\n          _iterator18.f();\n        }\n      }\n\n      if (hasSlotDescendant) {\n        assignSlotableForTree(nodeRoot(this));\n        assignSlotableForTree(nodeImpl);\n      }\n\n      this._modified();\n\n      nodeImpl._detach();\n\n      this._descendantRemoved(this, nodeImpl);\n\n      if (this.isConnected) {\n        if (nodeImpl._ceState === \"custom\") {\n          enqueueCECallbackReaction(nodeImpl, \"disconnectedCallback\", []);\n        }\n\n        var _iterator19 = _createForOfIteratorHelper(shadowIncludingDescendantsIterator(nodeImpl)),\n            _step19;\n\n        try {\n          for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n            var descendantImpl = _step19.value;\n\n            if (descendantImpl._ceState === \"custom\") {\n              enqueueCECallbackReaction(descendantImpl, \"disconnectedCallback\", []);\n            }\n          }\n        } catch (err) {\n          _iterator19.e(err);\n        } finally {\n          _iterator19.f();\n        }\n      }\n\n      if (!suppressObservers) {\n        queueTreeMutationRecord(this, [], [nodeImpl], oldPreviousSiblingImpl, oldNextSiblingImpl);\n      }\n\n      if (nodeImpl.nodeType === NODE_TYPE.TEXT_NODE) {\n        this._childTextContentChangeSteps();\n      }\n    }\n  }]);\n\n  return NodeImpl;\n}(EventTargetImpl);\n\nmodule.exports = {\n  implementation: NodeImpl\n};","map":null,"metadata":{},"sourceType":"script"}