{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar DOMException = require(\"domexception/webidl2js-wrapper\");\n\nvar _require = require(\"../node\"),\n    clone = _require.clone;\n\nvar NODE_TYPE = require(\"../node-type\");\n\nvar _require2 = require(\"../../browser/parser/index\"),\n    parseFragment = _require2.parseFragment;\n\nvar _require3 = require(\"../helpers/namespaces\"),\n    HTML_NS = _require3.HTML_NS;\n\nvar _require4 = require(\"../helpers/internal-constants\"),\n    domSymbolTree = _require4.domSymbolTree;\n\nvar _require5 = require(\"./boundary-point\"),\n    compareBoundaryPointsPosition = _require5.compareBoundaryPointsPosition;\n\nvar _require6 = require(\"../helpers/node\"),\n    nodeRoot = _require6.nodeRoot,\n    nodeLength = _require6.nodeLength,\n    isInclusiveAncestor = _require6.isInclusiveAncestor;\n\nvar _require7 = require(\"../helpers/create-element\"),\n    createElement = _require7.createElement;\n\nvar AbstractRangeImpl = require(\"./AbstractRange-impl\").implementation;\n\nvar Range = require(\"../generated/Range\");\n\nvar DocumentFragment = require(\"../generated/DocumentFragment\");\n\nvar _require8 = require(\"../generated/utils\"),\n    implForWrapper = _require8.implForWrapper;\n\nvar RANGE_COMPARISON_TYPE = {\n  START_TO_START: 0,\n  START_TO_END: 1,\n  END_TO_END: 2,\n  END_TO_START: 3\n};\n\nvar RangeImpl = /*#__PURE__*/function (_AbstractRangeImpl) {\n  _inherits(RangeImpl, _AbstractRangeImpl);\n\n  var _super = _createSuper(RangeImpl);\n\n  function RangeImpl(globalObject, args, privateData) {\n    var _this;\n\n    _classCallCheck(this, RangeImpl);\n\n    _this = _super.call(this, globalObject, args, privateData);\n    var defaultBoundaryPoint = {\n      node: implForWrapper(globalObject._document),\n      offset: 0\n    };\n    var _privateData$start = privateData.start,\n        start = _privateData$start === void 0 ? defaultBoundaryPoint : _privateData$start,\n        _privateData$end = privateData.end,\n        end = _privateData$end === void 0 ? defaultBoundaryPoint : _privateData$end;\n\n    _this._setLiveRangeStart(start.node, start.offset);\n\n    _this._setLiveRangeEnd(end.node, end.offset);\n\n    return _this;\n  } // https://dom.spec.whatwg.org/#dom-range-commonancestorcontainer\n\n\n  _createClass(RangeImpl, [{\n    key: \"commonAncestorContainer\",\n    get: function get() {\n      var _start = this._start,\n          _end = this._end;\n\n      var _iterator = _createForOfIteratorHelper(domSymbolTree.ancestorsIterator(_start.node)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var container = _step.value;\n\n          if (isInclusiveAncestor(container, _end.node)) {\n            return container;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return null;\n    } // https://dom.spec.whatwg.org/#dom-range-setstart\n\n  }, {\n    key: \"setStart\",\n    value: function setStart(node, offset) {\n      setBoundaryPointStart(this, node, offset);\n    } // https://dom.spec.whatwg.org/#dom-range-setend\n\n  }, {\n    key: \"setEnd\",\n    value: function setEnd(node, offset) {\n      setBoundaryPointEnd(this, node, offset);\n    } // https://dom.spec.whatwg.org/#dom-range-setstartbefore\n\n  }, {\n    key: \"setStartBefore\",\n    value: function setStartBefore(node) {\n      var parent = domSymbolTree.parent(node);\n\n      if (!parent) {\n        throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n      }\n\n      setBoundaryPointStart(this, parent, domSymbolTree.index(node));\n    } // https://dom.spec.whatwg.org/#dom-range-setstartafter\n\n  }, {\n    key: \"setStartAfter\",\n    value: function setStartAfter(node) {\n      var parent = domSymbolTree.parent(node);\n\n      if (!parent) {\n        throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n      }\n\n      setBoundaryPointStart(this, parent, domSymbolTree.index(node) + 1);\n    } // https://dom.spec.whatwg.org/#dom-range-setendbefore\n\n  }, {\n    key: \"setEndBefore\",\n    value: function setEndBefore(node) {\n      var parent = domSymbolTree.parent(node);\n\n      if (!parent) {\n        throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n      }\n\n      setBoundaryPointEnd(this, parent, domSymbolTree.index(node));\n    } // https://dom.spec.whatwg.org/#dom-range-setendafter\n\n  }, {\n    key: \"setEndAfter\",\n    value: function setEndAfter(node) {\n      var parent = domSymbolTree.parent(node);\n\n      if (!parent) {\n        throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n      }\n\n      setBoundaryPointEnd(this, parent, domSymbolTree.index(node) + 1);\n    } // https://dom.spec.whatwg.org/#dom-range-collapse\n\n  }, {\n    key: \"collapse\",\n    value: function collapse(toStart) {\n      if (toStart) {\n        this._setLiveRangeEnd(this._start.node, this._start.offset);\n      } else {\n        this._setLiveRangeStart(this._end.node, this._end.offset);\n      }\n    } // https://dom.spec.whatwg.org/#dom-range-selectnode\n\n  }, {\n    key: \"selectNode\",\n    value: function selectNode(node) {\n      selectNodeWithinRange(node, this);\n    } // https://dom.spec.whatwg.org/#dom-range-selectnodecontents\n\n  }, {\n    key: \"selectNodeContents\",\n    value: function selectNodeContents(node) {\n      if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n        throw DOMException.create(this._globalObject, [\"DocumentType Node can't be used as boundary point.\", \"InvalidNodeTypeError\"]);\n      }\n\n      var length = nodeLength(node);\n\n      this._setLiveRangeStart(node, 0);\n\n      this._setLiveRangeEnd(node, length);\n    } // https://dom.spec.whatwg.org/#dom-range-compareboundarypoints\n\n  }, {\n    key: \"compareBoundaryPoints\",\n    value: function compareBoundaryPoints(how, sourceRange) {\n      if (how !== RANGE_COMPARISON_TYPE.START_TO_START && how !== RANGE_COMPARISON_TYPE.START_TO_END && how !== RANGE_COMPARISON_TYPE.END_TO_END && how !== RANGE_COMPARISON_TYPE.END_TO_START) {\n        var message = \"The comparison method provided must be one of 'START_TO_START', 'START_TO_END', 'END_TO_END', \" + \"or 'END_TO_START'.\";\n        throw DOMException.create(this._globalObject, [message, \"NotSupportedError\"]);\n      }\n\n      if (this._root !== sourceRange._root) {\n        throw DOMException.create(this._globalObject, [\"The two Ranges are not in the same tree.\", \"WrongDocumentError\"]);\n      }\n\n      var thisPoint, otherPoint;\n\n      if (how === RANGE_COMPARISON_TYPE.START_TO_START) {\n        thisPoint = this._start;\n        otherPoint = sourceRange._start;\n      } else if (how === RANGE_COMPARISON_TYPE.START_TO_END) {\n        thisPoint = this._end;\n        otherPoint = sourceRange._start;\n      } else if (how === RANGE_COMPARISON_TYPE.END_TO_END) {\n        thisPoint = this._end;\n        otherPoint = sourceRange._end;\n      } else {\n        thisPoint = this._start;\n        otherPoint = sourceRange._end;\n      }\n\n      return compareBoundaryPointsPosition(thisPoint, otherPoint);\n    } // https://dom.spec.whatwg.org/#dom-range-deletecontents\n\n  }, {\n    key: \"deleteContents\",\n    value: function deleteContents() {\n      if (this.collapsed) {\n        return;\n      }\n\n      var originalStart = this._start,\n          originalEnd = this._end;\n\n      if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {\n        originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\n        return;\n      }\n\n      var nodesToRemove = [];\n      var currentNode = this._start.node;\n      var endNode = nextNodeDescendant(this._end.node);\n\n      while (currentNode && currentNode !== endNode) {\n        if (isContained(currentNode, this) && !isContained(domSymbolTree.parent(currentNode), this)) {\n          nodesToRemove.push(currentNode);\n        }\n\n        currentNode = domSymbolTree.following(currentNode);\n      }\n\n      var newNode, newOffset;\n\n      if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n        newNode = originalStart.node;\n        newOffset = originalStart.offset;\n      } else {\n        var referenceNode = originalStart.node;\n\n        while (referenceNode && !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)) {\n          referenceNode = domSymbolTree.parent(referenceNode);\n        }\n\n        newNode = domSymbolTree.parent(referenceNode);\n        newOffset = domSymbolTree.index(referenceNode) + 1;\n      }\n\n      if (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE) {\n        originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\n      }\n\n      for (var _i = 0, _nodesToRemove = nodesToRemove; _i < _nodesToRemove.length; _i++) {\n        var node = _nodesToRemove[_i];\n        var parent = domSymbolTree.parent(node);\n        parent.removeChild(node);\n      }\n\n      if (originalEnd.node.nodeType === NODE_TYPE.TEXT_NODE || originalEnd.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalEnd.node.nodeType === NODE_TYPE.COMMENT_NODE) {\n        originalEnd.node.replaceData(0, originalEnd.offset, \"\");\n      }\n\n      this._setLiveRangeStart(newNode, newOffset);\n\n      this._setLiveRangeEnd(newNode, newOffset);\n    } // https://dom.spec.whatwg.org/#dom-range-extractcontents\n\n  }, {\n    key: \"extractContents\",\n    value: function extractContents() {\n      return extractRange(this);\n    } // https://dom.spec.whatwg.org/#dom-range-clonecontents\n\n  }, {\n    key: \"cloneContents\",\n    value: function cloneContents() {\n      return cloneRange(this);\n    } // https://dom.spec.whatwg.org/#dom-range-insertnode\n\n  }, {\n    key: \"insertNode\",\n    value: function insertNode(node) {\n      insertNodeInRange(node, this);\n    } // https://dom.spec.whatwg.org/#dom-range-surroundcontents\n\n  }, {\n    key: \"surroundContents\",\n    value: function surroundContents(newParent) {\n      var node = this.commonAncestorContainer;\n      var endNode = nextNodeDescendant(node);\n\n      while (node !== endNode) {\n        if (node.nodeType !== NODE_TYPE.TEXT_NODE && isPartiallyContained(node, this)) {\n          throw DOMException.create(this._globalObject, [\"The Range has partially contains a non-Text node.\", \"InvalidStateError\"]);\n        }\n\n        node = domSymbolTree.following(node);\n      }\n\n      if (newParent.nodeType === NODE_TYPE.DOCUMENT_NODE || newParent.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE || newParent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n        throw DOMException.create(this._globalObject, [\"Invalid element type.\", \"InvalidNodeTypeError\"]);\n      }\n\n      var fragment = extractRange(this);\n\n      while (domSymbolTree.firstChild(newParent)) {\n        newParent.removeChild(domSymbolTree.firstChild(newParent));\n      }\n\n      insertNodeInRange(newParent, this);\n      newParent.appendChild(fragment);\n      selectNodeWithinRange(newParent, this);\n    } // https://dom.spec.whatwg.org/#dom-range-clonerange\n\n  }, {\n    key: \"cloneRange\",\n    value: function cloneRange() {\n      var _start = this._start,\n          _end = this._end,\n          _globalObject = this._globalObject;\n      return Range.createImpl(_globalObject, [], {\n        start: {\n          node: _start.node,\n          offset: _start.offset\n        },\n        end: {\n          node: _end.node,\n          offset: _end.offset\n        }\n      });\n    } // https://dom.spec.whatwg.org/#dom-range-detach\n\n  }, {\n    key: \"detach\",\n    value: function detach() {// Do nothing by spec!\n    } // https://dom.spec.whatwg.org/#dom-range-ispointinrange\n\n  }, {\n    key: \"isPointInRange\",\n    value: function isPointInRange(node, offset) {\n      if (nodeRoot(node) !== this._root) {\n        return false;\n      }\n\n      validateSetBoundaryPoint(node, offset);\n      var bp = {\n        node: node,\n        offset: offset\n      };\n\n      if (compareBoundaryPointsPosition(bp, this._start) === -1 || compareBoundaryPointsPosition(bp, this._end) === 1) {\n        return false;\n      }\n\n      return true;\n    } // https://dom.spec.whatwg.org/#dom-range-comparepoint\n\n  }, {\n    key: \"comparePoint\",\n    value: function comparePoint(node, offset) {\n      if (nodeRoot(node) !== this._root) {\n        throw DOMException.create(this._globalObject, [\"The given Node and the Range are not in the same tree.\", \"WrongDocumentError\"]);\n      }\n\n      validateSetBoundaryPoint(node, offset);\n      var bp = {\n        node: node,\n        offset: offset\n      };\n\n      if (compareBoundaryPointsPosition(bp, this._start) === -1) {\n        return -1;\n      } else if (compareBoundaryPointsPosition(bp, this._end) === 1) {\n        return 1;\n      }\n\n      return 0;\n    } // https://dom.spec.whatwg.org/#dom-range-intersectsnode\n\n  }, {\n    key: \"intersectsNode\",\n    value: function intersectsNode(node) {\n      if (nodeRoot(node) !== this._root) {\n        return false;\n      }\n\n      var parent = domSymbolTree.parent(node);\n\n      if (!parent) {\n        return true;\n      }\n\n      var offset = domSymbolTree.index(node);\n      return compareBoundaryPointsPosition({\n        node: parent,\n        offset: offset\n      }, this._end) === -1 && compareBoundaryPointsPosition({\n        node: parent,\n        offset: offset + 1\n      }, this._start) === 1;\n    } // https://dom.spec.whatwg.org/#dom-range-stringifier\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var s = \"\";\n      var _start = this._start,\n          _end = this._end;\n\n      if (_start.node === _end.node && _start.node.nodeType === NODE_TYPE.TEXT_NODE) {\n        return _start.node.data.slice(_start.offset, _end.offset);\n      }\n\n      if (_start.node.nodeType === NODE_TYPE.TEXT_NODE) {\n        s += _start.node.data.slice(_start.offset);\n      }\n\n      var currentNode = _start.node;\n      var endNode = nextNodeDescendant(_end.node);\n\n      while (currentNode && currentNode !== endNode) {\n        if (currentNode.nodeType === NODE_TYPE.TEXT_NODE && isContained(currentNode, this)) {\n          s += currentNode.data;\n        }\n\n        currentNode = domSymbolTree.following(currentNode);\n      }\n\n      if (_end.node.nodeType === NODE_TYPE.TEXT_NODE) {\n        s += _end.node.data.slice(0, _end.offset);\n      }\n\n      return s;\n    } // https://w3c.github.io/DOM-Parsing/#dom-range-createcontextualfragment\n\n  }, {\n    key: \"createContextualFragment\",\n    value: function createContextualFragment(fragment) {\n      var node = this._start.node;\n      var element;\n\n      switch (node.nodeType) {\n        case NODE_TYPE.DOCUMENT_NODE:\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n          element = null;\n          break;\n\n        case NODE_TYPE.ELEMENT_NODE:\n          element = node;\n          break;\n\n        case NODE_TYPE.TEXT_NODE:\n        case NODE_TYPE.COMMENT_NODE:\n          element = node.parentElement;\n          break;\n\n        default:\n          throw new Error(\"Internal error: Invalid range start node\");\n      }\n\n      if (element === null || element._ownerDocument._parsingMode === \"html\" && element._localName === \"html\" && element._namespaceURI === HTML_NS) {\n        element = createElement(node._ownerDocument, \"body\", HTML_NS);\n      }\n\n      return parseFragment(fragment, element);\n    } // https://dom.spec.whatwg.org/#concept-range-root\n\n  }, {\n    key: \"_root\",\n    get: function get() {\n      return nodeRoot(this._start.node);\n    }\n  }, {\n    key: \"_setLiveRangeStart\",\n    value: function _setLiveRangeStart(node, offset) {\n      if (this._start && this._start.node !== node) {\n        this._start.node._referencedRanges.delete(this);\n      }\n\n      if (!node._referencedRanges.has(this)) {\n        node._referencedRanges.add(this);\n      }\n\n      this._start = {\n        node: node,\n        offset: offset\n      };\n    }\n  }, {\n    key: \"_setLiveRangeEnd\",\n    value: function _setLiveRangeEnd(node, offset) {\n      if (this._end && this._end.node !== node) {\n        this._end.node._referencedRanges.delete(this);\n      }\n\n      if (!node._referencedRanges.has(this)) {\n        node._referencedRanges.add(this);\n      }\n\n      this._end = {\n        node: node,\n        offset: offset\n      };\n    }\n  }]);\n\n  return RangeImpl;\n}(AbstractRangeImpl);\n\nfunction nextNodeDescendant(node) {\n  while (node && !domSymbolTree.nextSibling(node)) {\n    node = domSymbolTree.parent(node);\n  }\n\n  if (!node) {\n    return null;\n  }\n\n  return domSymbolTree.nextSibling(node);\n} // https://dom.spec.whatwg.org/#concept-range-bp-set\n\n\nfunction validateSetBoundaryPoint(node, offset) {\n  if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n    throw DOMException.create(node._globalObject, [\"DocumentType Node can't be used as boundary point.\", \"InvalidNodeTypeError\"]);\n  }\n\n  if (offset > nodeLength(node)) {\n    throw DOMException.create(node._globalObject, [\"Offset out of bound.\", \"IndexSizeError\"]);\n  }\n}\n\nfunction setBoundaryPointStart(range, node, offset) {\n  validateSetBoundaryPoint(node, offset);\n  var bp = {\n    node: node,\n    offset: offset\n  };\n\n  if (nodeRoot(node) !== range._root || compareBoundaryPointsPosition(bp, range._end) === 1) {\n    range._setLiveRangeEnd(node, offset);\n  }\n\n  range._setLiveRangeStart(node, offset);\n}\n\nfunction setBoundaryPointEnd(range, node, offset) {\n  validateSetBoundaryPoint(node, offset);\n  var bp = {\n    node: node,\n    offset: offset\n  };\n\n  if (nodeRoot(node) !== range._root || compareBoundaryPointsPosition(bp, range._start) === -1) {\n    range._setLiveRangeStart(node, offset);\n  }\n\n  range._setLiveRangeEnd(node, offset);\n} // https://dom.spec.whatwg.org/#concept-range-select\n\n\nfunction selectNodeWithinRange(node, range) {\n  var parent = domSymbolTree.parent(node);\n\n  if (!parent) {\n    throw DOMException.create(node._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n  }\n\n  var index = domSymbolTree.index(node);\n\n  range._setLiveRangeStart(parent, index);\n\n  range._setLiveRangeEnd(parent, index + 1);\n} // https://dom.spec.whatwg.org/#contained\n\n\nfunction isContained(node, range) {\n  var _start = range._start,\n      _end = range._end;\n  return compareBoundaryPointsPosition({\n    node: node,\n    offset: 0\n  }, _start) === 1 && compareBoundaryPointsPosition({\n    node: node,\n    offset: nodeLength(node)\n  }, _end) === -1;\n} // https://dom.spec.whatwg.org/#partially-contained\n\n\nfunction isPartiallyContained(node, range) {\n  var _start = range._start,\n      _end = range._end;\n  return isInclusiveAncestor(node, _start.node) && !isInclusiveAncestor(node, _end.node) || !isInclusiveAncestor(node, _start.node) && isInclusiveAncestor(node, _end.node);\n} // https://dom.spec.whatwg.org/#concept-range-insert\n\n\nfunction insertNodeInRange(node, range) {\n  var _range$_start = range._start,\n      startNode = _range$_start.node,\n      startOffset = _range$_start.offset;\n\n  if (startNode.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || startNode.nodeType === NODE_TYPE.COMMENT_NODE || startNode.nodeType === NODE_TYPE.TEXT_NODE && !domSymbolTree.parent(startNode) || node === startNode) {\n    throw DOMException.create(node._globalObject, [\"Invalid start node.\", \"HierarchyRequestError\"]);\n  }\n\n  var referenceNode = startNode.nodeType === NODE_TYPE.TEXT_NODE ? startNode : domSymbolTree.childrenToArray(startNode)[startOffset] || null;\n  var parent = !referenceNode ? startNode : domSymbolTree.parent(referenceNode);\n\n  parent._preInsertValidity(node, referenceNode);\n\n  if (startNode.nodeType === NODE_TYPE.TEXT_NODE) {\n    referenceNode = startNode.splitText(startOffset);\n  }\n\n  if (node === referenceNode) {\n    referenceNode = domSymbolTree.nextSibling(referenceNode);\n  }\n\n  var nodeParent = domSymbolTree.parent(node);\n\n  if (nodeParent) {\n    nodeParent.removeChild(node);\n  }\n\n  var newOffset = !referenceNode ? nodeLength(parent) : domSymbolTree.index(referenceNode);\n  newOffset += node.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? nodeLength(node) : 1;\n  parent.insertBefore(node, referenceNode);\n\n  if (range.collapsed) {\n    range._setLiveRangeEnd(parent, newOffset);\n  }\n} // https://dom.spec.whatwg.org/#concept-range-clone\n\n\nfunction cloneRange(range) {\n  var originalStart = range._start,\n      originalEnd = range._end,\n      _globalObject = range._globalObject;\n  var fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: originalStart.node._ownerDocument\n  });\n\n  if (range.collapsed) {\n    return fragment;\n  }\n\n  if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    var cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\n    fragment.appendChild(cloned);\n    return fragment;\n  }\n\n  var commonAncestor = originalStart.node;\n\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\n    commonAncestor = domSymbolTree.parent(commonAncestor);\n  }\n\n  var firstPartialContainedChild = null;\n\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    var candidate = domSymbolTree.firstChild(commonAncestor);\n\n    while (!firstPartialContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        firstPartialContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.nextSibling(candidate);\n    }\n  }\n\n  var lastPartiallyContainedChild = null;\n\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\n    var _candidate = domSymbolTree.lastChild(commonAncestor);\n\n    while (!lastPartiallyContainedChild) {\n      if (isPartiallyContained(_candidate, range)) {\n        lastPartiallyContainedChild = _candidate;\n      }\n\n      _candidate = domSymbolTree.previousSibling(_candidate);\n    }\n  }\n\n  var containedChildren = domSymbolTree.childrenToArray(commonAncestor).filter(function (node) {\n    return isContained(node, range);\n  });\n  var hasDoctypeChildren = containedChildren.some(function (node) {\n    return node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE;\n  });\n\n  if (hasDoctypeChildren) {\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\n  }\n\n  if (firstPartialContainedChild !== null && (firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    var _cloned = clone(originalStart.node);\n\n    _cloned._data = _cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\n    fragment.appendChild(_cloned);\n  } else if (firstPartialContainedChild !== null) {\n    var _cloned2 = clone(firstPartialContainedChild);\n\n    fragment.appendChild(_cloned2);\n    var subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: originalStart.node,\n        offset: originalStart.offset\n      },\n      end: {\n        node: firstPartialContainedChild,\n        offset: nodeLength(firstPartialContainedChild)\n      }\n    });\n    var subfragment = cloneRange(subrange);\n\n    _cloned2.appendChild(subfragment);\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(containedChildren),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var containedChild = _step2.value;\n\n      var _cloned5 = clone(containedChild, undefined, true);\n\n      fragment.appendChild(_cloned5);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  if (lastPartiallyContainedChild !== null && (lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    var _cloned3 = clone(originalEnd.node);\n\n    _cloned3._data = _cloned3.substringData(0, originalEnd.offset);\n    fragment.appendChild(_cloned3);\n  } else if (lastPartiallyContainedChild !== null) {\n    var _cloned4 = clone(lastPartiallyContainedChild);\n\n    fragment.appendChild(_cloned4);\n\n    var _subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: lastPartiallyContainedChild,\n        offset: 0\n      },\n      end: {\n        node: originalEnd.node,\n        offset: originalEnd.offset\n      }\n    });\n\n    var _subfragment = cloneRange(_subrange);\n\n    _cloned4.appendChild(_subfragment);\n  }\n\n  return fragment;\n} // https://dom.spec.whatwg.org/#concept-range-extract\n\n\nfunction extractRange(range) {\n  var originalStart = range._start,\n      originalEnd = range._end,\n      _globalObject = range._globalObject;\n  var fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: originalStart.node._ownerDocument\n  });\n\n  if (range.collapsed) {\n    return fragment;\n  }\n\n  if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    var cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\n    fragment.appendChild(cloned);\n    originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\n    return fragment;\n  }\n\n  var commonAncestor = originalStart.node;\n\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\n    commonAncestor = domSymbolTree.parent(commonAncestor);\n  }\n\n  var firstPartialContainedChild = null;\n\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    var candidate = domSymbolTree.firstChild(commonAncestor);\n\n    while (!firstPartialContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        firstPartialContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.nextSibling(candidate);\n    }\n  }\n\n  var lastPartiallyContainedChild = null;\n\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\n    var _candidate2 = domSymbolTree.lastChild(commonAncestor);\n\n    while (!lastPartiallyContainedChild) {\n      if (isPartiallyContained(_candidate2, range)) {\n        lastPartiallyContainedChild = _candidate2;\n      }\n\n      _candidate2 = domSymbolTree.previousSibling(_candidate2);\n    }\n  }\n\n  var containedChildren = domSymbolTree.childrenToArray(commonAncestor).filter(function (node) {\n    return isContained(node, range);\n  });\n  var hasDoctypeChildren = containedChildren.some(function (node) {\n    return node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE;\n  });\n\n  if (hasDoctypeChildren) {\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\n  }\n\n  var newNode, newOffset;\n\n  if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    newNode = originalStart.node;\n    newOffset = originalStart.offset;\n  } else {\n    var referenceNode = originalStart.node;\n\n    while (referenceNode && !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)) {\n      referenceNode = domSymbolTree.parent(referenceNode);\n    }\n\n    newNode = domSymbolTree.parent(referenceNode);\n    newOffset = domSymbolTree.index(referenceNode) + 1;\n  }\n\n  if (firstPartialContainedChild !== null && (firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    var _cloned6 = clone(originalStart.node);\n\n    _cloned6._data = _cloned6.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\n    fragment.appendChild(_cloned6);\n    originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\n  } else if (firstPartialContainedChild !== null) {\n    var _cloned7 = clone(firstPartialContainedChild);\n\n    fragment.appendChild(_cloned7);\n    var subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: originalStart.node,\n        offset: originalStart.offset\n      },\n      end: {\n        node: firstPartialContainedChild,\n        offset: nodeLength(firstPartialContainedChild)\n      }\n    });\n    var subfragment = extractRange(subrange);\n\n    _cloned7.appendChild(subfragment);\n  }\n\n  var _iterator3 = _createForOfIteratorHelper(containedChildren),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var containedChild = _step3.value;\n      fragment.appendChild(containedChild);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  if (lastPartiallyContainedChild !== null && (lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    var _cloned8 = clone(originalEnd.node);\n\n    _cloned8._data = _cloned8.substringData(0, originalEnd.offset);\n    fragment.appendChild(_cloned8);\n    originalEnd.node.replaceData(0, originalEnd.offset, \"\");\n  } else if (lastPartiallyContainedChild !== null) {\n    var _cloned9 = clone(lastPartiallyContainedChild);\n\n    fragment.appendChild(_cloned9);\n\n    var _subrange2 = Range.createImpl(_globalObject, [], {\n      start: {\n        node: lastPartiallyContainedChild,\n        offset: 0\n      },\n      end: {\n        node: originalEnd.node,\n        offset: originalEnd.offset\n      }\n    });\n\n    var _subfragment2 = extractRange(_subrange2);\n\n    _cloned9.appendChild(_subfragment2);\n  }\n\n  range._setLiveRangeStart(newNode, newOffset);\n\n  range._setLiveRangeEnd(newNode, newOffset);\n\n  return fragment;\n}\n\nmodule.exports = {\n  implementation: RangeImpl,\n  setBoundaryPointStart: setBoundaryPointStart,\n  setBoundaryPointEnd: setBoundaryPointEnd\n};","map":null,"metadata":{},"sourceType":"script"}