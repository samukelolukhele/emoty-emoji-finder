{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/client/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nvar notImplemented = require(\"../../browser/not-implemented\");\n\nvar idlUtils = require(\"../generated/utils\");\n\nvar _require = require(\"../../utils\"),\n    Canvas = _require.Canvas;\n\nvar HTMLCanvasElementImpl = /*#__PURE__*/function (_HTMLElementImpl) {\n  _inherits(HTMLCanvasElementImpl, _HTMLElementImpl);\n\n  var _super = _createSuper(HTMLCanvasElementImpl);\n\n  function HTMLCanvasElementImpl() {\n    _classCallCheck(this, HTMLCanvasElementImpl);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(HTMLCanvasElementImpl, [{\n    key: \"_attrModified\",\n    value: function _attrModified(name, value, oldValue) {\n      if (this._canvas && (name === \"width\" || name === \"height\")) {\n        this._canvas[name] = parseInt(value);\n      }\n\n      _get(_getPrototypeOf(HTMLCanvasElementImpl.prototype), \"_attrModified\", this).call(this, name, value, oldValue);\n    }\n  }, {\n    key: \"_getCanvas\",\n    value: function _getCanvas() {\n      if (Canvas && !this._canvas) {\n        this._canvas = Canvas.createCanvas(this.width, this.height);\n      }\n\n      return this._canvas;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext(contextId) {\n      var canvas = this._getCanvas();\n\n      if (canvas) {\n        if (!this._context) {\n          this._context = canvas.getContext(contextId) || null;\n\n          if (this._context) {\n            // Override the native canvas reference with our wrapper. This is the\n            // reason why we need to locally cache _context, since each call to\n            // canvas.getContext(contextId) would replace this reference again.\n            // Perhaps in the longer term, a better solution would be to create a\n            // full wrapper for the Context object as well.\n            this._context.canvas = idlUtils.wrapperForImpl(this);\n            wrapNodeCanvasMethod(this._context, \"createPattern\");\n            wrapNodeCanvasMethod(this._context, \"drawImage\");\n          }\n        }\n\n        return this._context;\n      }\n\n      notImplemented(\"HTMLCanvasElement.prototype.getContext (without installing the canvas npm package)\", this._ownerDocument._defaultView);\n      return null;\n    }\n  }, {\n    key: \"toDataURL\",\n    value: function toDataURL() {\n      var canvas = this._getCanvas();\n\n      if (canvas) {\n        return canvas.toDataURL.apply(canvas, arguments);\n      }\n\n      notImplemented(\"HTMLCanvasElement.prototype.toDataURL (without installing the canvas npm package)\", this._ownerDocument._defaultView);\n      return null;\n    }\n  }, {\n    key: \"toBlob\",\n    value: function toBlob(callback, type, qualityArgument) {\n      var window = this._ownerDocument._defaultView;\n\n      var canvas = this._getCanvas();\n\n      if (canvas) {\n        var options = {};\n\n        switch (type) {\n          case \"image/jpg\":\n          case \"image/jpeg\":\n            type = \"image/jpeg\";\n            options.quality = qualityArgument;\n            break;\n\n          default:\n            type = \"image/png\";\n        }\n\n        canvas.toBuffer(function (err, buff) {\n          if (err) {\n            throw err;\n          }\n\n          callback(new window.Blob([buff], {\n            type: type\n          }));\n        }, type, options);\n      } else {\n        notImplemented(\"HTMLCanvasElement.prototype.toBlob (without installing the canvas npm package)\", window);\n      }\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      var parsed = parseInt(this.getAttributeNS(null, \"width\"));\n      return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 300 : parsed;\n    },\n    set: function set(v) {\n      v = v > 2147483647 ? 300 : v;\n      this.setAttributeNS(null, \"width\", String(v));\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      var parsed = parseInt(this.getAttributeNS(null, \"height\"));\n      return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 150 : parsed;\n    },\n    set: function set(v) {\n      v = v > 2147483647 ? 150 : v;\n      this.setAttributeNS(null, \"height\", String(v));\n    }\n  }]);\n\n  return HTMLCanvasElementImpl;\n}(HTMLElementImpl); // We need to wrap the methods that receive an image or canvas object\n// (luckily, always as the first argument), so that these objects can be\n// unwrapped an the expected types passed.\n\n\nfunction wrapNodeCanvasMethod(ctx, name) {\n  var prev = ctx[name];\n\n  ctx[name] = function (image) {\n    var impl = idlUtils.implForWrapper(image);\n\n    if (impl) {\n      if (impl instanceof HTMLCanvasElementImpl && !impl._canvas) {\n        impl._getCanvas();\n      }\n\n      image = impl._image || impl._canvas;\n    }\n\n    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      rest[_key - 1] = arguments[_key];\n    }\n\n    return prev.call.apply(prev, [ctx, image].concat(rest));\n  };\n}\n\nmodule.exports = {\n  implementation: HTMLCanvasElementImpl\n};","map":null,"metadata":{},"sourceType":"script"}