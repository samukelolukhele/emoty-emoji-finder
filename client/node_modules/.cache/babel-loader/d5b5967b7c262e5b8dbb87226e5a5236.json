{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/samukelolukhele/Desktop/Documents/Udemy Work & Notes/Web Development - App Brewery/ReactJS/React Emojipedia Project/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar xnv = require(\"xml-name-validator\");\n\nvar attributeUtils = require(\"./attributes\");\n\nvar _require = require(\"./constants\"),\n    NAMESPACES = _require.NAMESPACES,\n    VOID_ELEMENTS = _require.VOID_ELEMENTS,\n    NODE_TYPES = _require.NODE_TYPES;\n\nvar XML_CHAR = /^(\\x09|\\x0A|\\x0D|[\\x20-\\uD7FF]|[\\uE000-\\uFFFD]|(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]))*$/;\nvar PUBID_CHAR = /^(\\x20|\\x0D|\\x0A|[a-zA-Z0-9]|[-'()+,./:=?;!*#@$_%])*$/;\n\nfunction asciiCaseInsensitiveMatch(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (var i = 0; i < a.length; ++i) {\n    if ((a.charCodeAt(i) | 32) !== (b.charCodeAt(i) | 32)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction recordNamespaceInformation(element, map, prefixMap) {\n  var defaultNamespaceAttrValue = null;\n\n  for (var i = 0; i < element.attributes.length; ++i) {\n    var attr = element.attributes[i];\n\n    if (attr.namespaceURI === NAMESPACES.XMLNS) {\n      if (attr.prefix === null) {\n        defaultNamespaceAttrValue = attr.value;\n        continue;\n      }\n\n      var namespaceDefinition = attr.value;\n\n      if (namespaceDefinition === NAMESPACES.XML) {\n        continue;\n      } // This is exactly the other way than the spec says, but that's intended.\n      // All the maps coalesce null to the empty string (explained in the\n      // spec), so instead of doing that every time, just do it once here.\n\n\n      if (namespaceDefinition === null) {\n        namespaceDefinition = \"\";\n      }\n\n      if (namespaceDefinition in map && map[namespaceDefinition].includes(attr.localName)) {\n        continue;\n      }\n\n      if (!(namespaceDefinition in map)) {\n        map[namespaceDefinition] = [];\n      }\n\n      map[namespaceDefinition].push(attr.localName);\n      prefixMap[attr.localName] = namespaceDefinition;\n    }\n  }\n\n  return defaultNamespaceAttrValue;\n}\n\nfunction serializeDocumentType(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !PUBID_CHAR.test(node.publicId)) {\n    throw new Error(\"Failed to serialize XML: document type node publicId is not well-formed.\");\n  }\n\n  if (requireWellFormed && (!XML_CHAR.test(node.systemId) || node.systemId.includes('\"') && node.systemId.includes(\"'\"))) {\n    throw new Error(\"Failed to serialize XML: document type node systemId is not well-formed.\");\n  }\n\n  var markup = \"<!DOCTYPE \".concat(node.name);\n\n  if (node.publicId !== \"\") {\n    markup += \" PUBLIC \\\"\".concat(node.publicId, \"\\\"\");\n  } else if (node.systemId !== \"\") {\n    markup += \" SYSTEM\";\n  }\n\n  if (node.systemId !== \"\") {\n    markup += \" \\\"\".concat(node.systemId, \"\\\"\");\n  }\n\n  return markup + \">\";\n}\n\nfunction serializeProcessingInstruction(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && (node.target.includes(\":\") || asciiCaseInsensitiveMatch(node.target, \"xml\"))) {\n    throw new Error(\"Failed to serialize XML: processing instruction node target is not well-formed.\");\n  }\n\n  if (requireWellFormed && (!XML_CHAR.test(node.data) || node.data.includes(\"?>\"))) {\n    throw new Error(\"Failed to serialize XML: processing instruction node data is not well-formed.\");\n  }\n\n  return \"<?\".concat(node.target, \" \").concat(node.data, \"?>\");\n}\n\nfunction serializeDocument(node, namespace, prefixMap, requireWellFormed, refs) {\n  if (requireWellFormed && node.documentElement === null) {\n    throw new Error(\"Failed to serialize XML: document does not have a document element.\");\n  }\n\n  var serializedDocument = \"\";\n\n  var _iterator = _createForOfIteratorHelper(node.childNodes),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var child = _step.value;\n      serializedDocument += xmlSerialization(child, namespace, prefixMap, requireWellFormed, refs);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return serializedDocument;\n}\n\nfunction serializeDocumentFragment(node, namespace, prefixMap, requireWellFormed, refs) {\n  var markup = \"\";\n\n  var _iterator2 = _createForOfIteratorHelper(node.childNodes),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var child = _step2.value;\n      markup += xmlSerialization(child, namespace, prefixMap, requireWellFormed, refs);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return markup;\n}\n\nfunction serializeText(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: text node data is not well-formed.\");\n  }\n\n  return node.data.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\n\nfunction serializeComment(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: comment node data is not well-formed.\");\n  }\n\n  if (requireWellFormed && (node.data.includes(\"--\") || node.data.endsWith(\"-\"))) {\n    throw new Error(\"Failed to serialize XML: found hyphens in illegal places in comment node data.\");\n  }\n\n  return \"<!--\".concat(node.data, \"-->\");\n}\n\nfunction serializeElement(node, namespace, prefixMap, requireWellFormed, refs) {\n  if (requireWellFormed && (node.localName.includes(\":\") || !xnv.name(node.localName))) {\n    throw new Error(\"Failed to serialize XML: element node localName is not a valid XML name.\");\n  }\n\n  var markup = \"<\";\n  var qualifiedName = \"\";\n  var skipEndTag = false;\n  var ignoreNamespaceDefinitionAttr = false;\n  var map = Object.assign({}, prefixMap);\n  var localPrefixesMap = Object.create(null);\n  var localDefaultNamespace = recordNamespaceInformation(node, map, localPrefixesMap);\n  var inheritedNs = namespace;\n  var ns = node.namespaceURI;\n\n  if (inheritedNs === ns) {\n    if (localDefaultNamespace !== null) {\n      ignoreNamespaceDefinitionAttr = true;\n    }\n\n    if (ns === NAMESPACES.XML) {\n      qualifiedName = \"xml:\" + node.localName;\n    } else {\n      qualifiedName = node.localName;\n    }\n\n    markup += qualifiedName;\n  } else {\n    var prefix = node.prefix;\n    var candidatePrefix = attributeUtils.preferredPrefixString(map, ns, prefix);\n\n    if (prefix === \"xmlns\") {\n      if (requireWellFormed) {\n        throw new Error(\"Failed to serialize XML: element nodes can't have a prefix of \\\"xmlns\\\".\");\n      }\n\n      candidatePrefix = \"xmlns\";\n    }\n\n    if (candidatePrefix !== null) {\n      qualifiedName = candidatePrefix + \":\" + node.localName;\n\n      if (localDefaultNamespace !== null && localDefaultNamespace !== NAMESPACES.XML) {\n        inheritedNs = localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n\n      markup += qualifiedName;\n    } else if (prefix !== null) {\n      if (prefix in localPrefixesMap) {\n        prefix = attributeUtils.generatePrefix(map, ns, refs.prefixIndex++);\n      }\n\n      if (map[ns]) {\n        map[ns].push(prefix);\n      } else {\n        map[ns] = [prefix];\n      }\n\n      qualifiedName = prefix + \":\" + node.localName;\n      markup += \"\".concat(qualifiedName, \" xmlns:\").concat(prefix, \"=\\\"\").concat(attributeUtils.serializeAttributeValue(ns, requireWellFormed), \"\\\"\");\n\n      if (localDefaultNamespace !== null) {\n        inheritedNs = localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n    } else if (localDefaultNamespace === null || localDefaultNamespace !== ns) {\n      ignoreNamespaceDefinitionAttr = true;\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += \"\".concat(qualifiedName, \" xmlns=\\\"\").concat(attributeUtils.serializeAttributeValue(ns, requireWellFormed), \"\\\"\");\n    } else {\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += qualifiedName;\n    }\n  }\n\n  markup += attributeUtils.serializeAttributes(node, map, localPrefixesMap, ignoreNamespaceDefinitionAttr, requireWellFormed, refs);\n\n  if (ns === NAMESPACES.HTML && node.childNodes.length === 0 && VOID_ELEMENTS.has(node.localName)) {\n    markup += \" /\";\n    skipEndTag = true;\n  } else if (ns !== NAMESPACES.HTML && node.childNodes.length === 0) {\n    markup += \"/\";\n    skipEndTag = true;\n  }\n\n  markup += \">\";\n\n  if (skipEndTag) {\n    return markup;\n  }\n\n  if (ns === NAMESPACES.HTML && node.localName === \"template\") {\n    markup += xmlSerialization(node.content, inheritedNs, map, requireWellFormed, refs);\n  } else {\n    var _iterator3 = _createForOfIteratorHelper(node.childNodes),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var child = _step3.value;\n        markup += xmlSerialization(child, inheritedNs, map, requireWellFormed, refs);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n\n  markup += \"</\".concat(qualifiedName, \">\");\n  return markup;\n}\n\nfunction serializeCDATASection(node) {\n  return \"<![CDATA[\" + node.data + \"]]>\";\n}\n/**\n * @param {{prefixIndex: number}} refs\n */\n\n\nfunction xmlSerialization(node, namespace, prefixMap, requireWellFormed, refs) {\n  switch (node.nodeType) {\n    case NODE_TYPES.ELEMENT_NODE:\n      return serializeElement(node, namespace, prefixMap, requireWellFormed, refs);\n\n    case NODE_TYPES.DOCUMENT_NODE:\n      return serializeDocument(node, namespace, prefixMap, requireWellFormed, refs);\n\n    case NODE_TYPES.COMMENT_NODE:\n      return serializeComment(node, namespace, prefixMap, requireWellFormed);\n\n    case NODE_TYPES.TEXT_NODE:\n      return serializeText(node, namespace, prefixMap, requireWellFormed);\n\n    case NODE_TYPES.DOCUMENT_FRAGMENT_NODE:\n      return serializeDocumentFragment(node, namespace, prefixMap, requireWellFormed, refs);\n\n    case NODE_TYPES.DOCUMENT_TYPE_NODE:\n      return serializeDocumentType(node, namespace, prefixMap, requireWellFormed);\n\n    case NODE_TYPES.PROCESSING_INSTRUCTION_NODE:\n      return serializeProcessingInstruction(node, namespace, prefixMap, requireWellFormed);\n\n    case NODE_TYPES.ATTRIBUTE_NODE:\n      return \"\";\n\n    case NODE_TYPES.CDATA_SECTION_NODE:\n      return serializeCDATASection(node);\n\n    default:\n      throw new TypeError(\"Failed to serialize XML: only Nodes can be serialized.\");\n  }\n}\n\nmodule.exports = function (root) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$requireWellForme = _ref.requireWellFormed,\n      requireWellFormed = _ref$requireWellForme === void 0 ? false : _ref$requireWellForme;\n\n  var namespacePrefixMap = Object.create(null);\n  namespacePrefixMap[\"http://www.w3.org/XML/1998/namespace\"] = [\"xml\"];\n  return xmlSerialization(root, null, namespacePrefixMap, requireWellFormed, {\n    prefixIndex: 1\n  });\n};","map":null,"metadata":{},"sourceType":"script"}